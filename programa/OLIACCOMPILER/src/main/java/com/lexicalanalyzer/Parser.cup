package com.lexicalanalyzer;

// Importaciones necesarias
import java_cup.runtime.*;
import com.lexicalanalyzer.sym.*;

package com.lexicalanalyzer;
import lexicalanalyzer.sym.*;

parser code {:
    public void report_error(String message, Object info) {
        System.err.println(">>> Error de análisis sintáctico detectado: " + message);
        error_count++;
    }

    public void report_fatal_error(String message, Object info) {
        System.err.println(">>> Error FATAL de análisis sintáctico: " + message);
        throw new Error(message);
    }
:};



terminal INT_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, CHAR_LITERAL;
terminal IF, ELIF, ELSE, WHILE, FOR, DO, BREAK;
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;
terminal INT_MATRIX, FLOAT_MATRIX, STRING_MATRIX, CHAR_MATRIX, BOOLEAN_MATRIX;
terminal ADDITION_ONE, SUBTRACT_ONE, POWERS, ADDITION, SUBTRACT, MULTIPLICATION, DIVISION, MODULE;
terminal CONJUNCTION, DISJUNCTION, DENIAL;
terminal EQ, NEQ, LE, LT, GE, GT;
terminal LBRACKET, RBRACKET, COMMA;
terminal PARENTHESIS_L, PARENTHESIS_R, END_LINE, OPEN_BLOCK, CLOSE_BLOCK;
terminal ASSIGN;
terminal READ_INT, READ_FLOAT, WRITE_INT, WRITE_FLOAT, WRITE_STRING, WRITE_BOOLEAN;
terminal RETURN, VOID, COMMENT_BLOCK, COMMENT_LINE, MAIN;
terminal ID;

// No terminales
non terminal programa, main_func, func_decl, func_list, param_list, param, block;
non terminal stmt_list, stmt, var_decl, assign_stmt, var_decl_asisgn_stmt;
non terminal expr, arith_expr, rel_expr, logic_expr, literal, control_struct;
non terminal if_stmt, if_elif_stmt, if_else_stmt, if_elif_else_stmt, elif_blocks, elif_block;
non terminal do_while_stmt, for_stmt, return_stmt, break_stmt, type, comment;
non terminal func_call, arg_list, write_stmt, read_stmt;
non terminal array_decl;

precedence left EQ, NEQ, LT, LE, GT, GE;
precedence left ADDITION, SUBTRACT;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence right POWERS;
precedence left PARENTHESIS_L;

start with programa;

programa ::=
    main_func
    | func_list
    | error {: 
        System.out.println(">>> Error de sintaxis en el programa."); 
        parser.error_count++; 
    :};

main_func ::= VOID MAIN PARENTHESIS_L PARENTHESIS_R block;

func_decl ::= type ID PARENTHESIS_L param_list PARENTHESIS_R block;

func_list ::=
    func_decl func_list
    | func_decl;

param_list ::=
    param COMMA param_list
    | param
    | error {: System.out.println(">>> Error de sintaxis en lista de parámetros."); parser.error_count++; :};;

param ::= type ID | ;

block ::= OPEN_BLOCK stmt_list CLOSE_BLOCK
    | error CLOSE_BLOCK {: System.out.println(">>> Error de sintaxis en un bloque."); parser.error_count++; :};

stmt_list ::=
    stmt stmt_list
    | stmt;

stmt ::=
    var_decl END_LINE
    | assign_stmt END_LINE
    | var_decl_asisgn_stmt END_LINE
    | control_struct
    | read_stmt END_LINE
    | write_stmt END_LINE
    | return_stmt END_LINE
    | break_stmt END_LINE
    | comment
    | error END_LINE {: System.out.println(">>> Error de sintaxis en una instrucción."); parser.error_count++; :};

var_decl ::=
    type ID
    | array_decl;

array_decl ::=
    type ID LBRACKET INT_LITERAL RBRACKET LBRACKET INT_LITERAL RBRACKET
    | INT_MATRIX
    | FLOAT_MATRIX
    | STRING_MATRIX
    | CHAR_MATRIX
    | BOOLEAN_MATRIX;

assign_stmt ::=
    ID ASSIGN expr
    | ID ADDITION_ONE
    | ID SUBTRACT_ONE;

var_decl_asisgn_stmt ::=
    var_decl ASSIGN expr
    | array_decl LBRACKET INT_LITERAL RBRACKET LBRACKET INT_LITERAL RBRACKET ASSIGN expr;

expr ::=
    func_call
    | arith_expr
    | rel_expr
    | logic_expr
    | literal;

arith_expr ::=
    expr ADDITION expr
    | expr SUBTRACT expr
    | expr DIVISION expr
    | expr MULTIPLICATION expr
    | expr POWERS expr
    | expr MODULE expr;

rel_expr ::=
    expr LT expr
    | expr LE expr
    | expr GT expr
    | expr GE expr
    | expr EQ expr
    | expr NEQ expr;

logic_expr ::= PARENTHESIS_L expr CONJUNCTION expr PARENTHESIS_R | PARENTHESIS_L expr DISJUNCTION expr PARENTHESIS_R | DENIAL expr;

literal ::=
    BOOLEAN_LITERAL
    | STRING_LITERAL
    | CHAR_LITERAL
    | FLOAT_LITERAL
    | INT_LITERAL;

control_struct ::=
    if_elif_else_stmt
    | if_elif_stmt
    | if_else_stmt
    | if_stmt
    | do_while_stmt
    | for_stmt;

if_elif_else_stmt ::=
    IF PARENTHESIS_L expr PARENTHESIS_R block elif_blocks ELSE block;

if_else_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block ELSE block;

if_elif_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block elif_blocks;

if_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block;

elif_blocks ::=
    elif_block elif_blocks
    | elif_block;

elif_block ::= ELIF PARENTHESIS_L expr PARENTHESIS_R block;

do_while_stmt ::= DO block WHILE PARENTHESIS_L expr PARENTHESIS_R;

for_stmt ::= FOR PARENTHESIS_L assign_stmt END_LINE expr END_LINE assign_stmt PARENTHESIS_R block;

return_stmt ::= RETURN expr;

break_stmt ::= BREAK;

type ::= 
    INT
    | FLOAT
    | BOOLEAN
    | CHAR
    | STRING
    | INT_MATRIX
    | FLOAT_MATRIX
    | STRING_MATRIX
    | CHAR_MATRIX
    | BOOLEAN_MATRIX;


comment ::= 
    COMMENT_BLOCK
    | COMMENT_LINE;

func_call ::=
    ID PARENTHESIS_L arg_list PARENTHESIS_R
    | ID;

arg_list ::=
    expr COMMA arg_list
    | expr;

write_stmt ::= 
    WRITE_INT INT_LITERAL 
    | WRITE_INT ID
    | WRITE_FLOAT FLOAT_LITERAL 
    | WRITE_FLOAT ID
    | WRITE_STRING STRING_LITERAL 
    | WRITE_STRING ID
    | WRITE_BOOLEAN BOOLEAN_LITERAL 
    | WRITE_BOOLEAN ID;

read_stmt ::= 
    READ_INT ID
    | READ_FLOAT ID;
