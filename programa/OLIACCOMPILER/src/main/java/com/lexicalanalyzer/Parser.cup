package com.lexicalanalyzer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;

parser code {:
    public int error_count = 0;
    public int error_semantic_count = 0;
    private Map<String, Function> Functions = new HashMap<>() ;
    private Map<String, TablaDeSimbolos> FunctionTables = new HashMap<>() ;
    private TablaDeSimbolos ActualTable = null;

    // Modificar para que reporte todos los errores
    public void syntax_error(Symbol s) {
        if (s != null) {
            System.out.println("Error sintáctico en la línea " +(s.left + 1) +
            ", columna " + (s.right + 1) + ": " + s.value);
        }
        error_count++;
    }

    public void report_fatal_error(String message, Object info) {
        System.err.println(">>> Error FATAL de análisis sintáctico: " + message);
    }

    public void createFunction(String pTypeReturn, String pName, int pRow, int pColumn){
        if(Functions.containsKey(pName)){
            ActualTable = null;
            System.err.println("Error semántico: La función " + pName + 
                " está duplicada");
            error_semantic_count++;
        }
        else{
            Function function = new Function(pTypeReturn, pName, pRow, pColumn, true);
            Functions.put(pName, function);
            TablaDeSimbolos table = new TablaDeSimbolos(null);
            FunctionTables.put(pName, table);
            ActualTable = table;
        }
    }

    public LineaTabla createVar(String pTypeReturn, String pName, int pRow,
        int pColumn, boolean pInitialized){
        LineaTabla line = new LineaTabla(pTypeReturn, pName, pRow,pColumn, pInitialized);
        if(!ActualTable.AgregarDato(line)){
            System.err.println("Error semántico: La función " + pName + 
                " está duplicada");
            return null;
        }
        return line;
    }

    public void printTables(){
        System.out.println(Functions.toString() + "\n");
        Collection<TablaDeSimbolos> tables = FunctionTables.values();
        for (TablaDeSimbolos table : tables){
            System.out.println(table.toString());
        }
    }

    public void semantic_error(Symbol s, String mensaje) {
        if (s != null) {
            System.err.println("Error semántico en la línea " + (s.left + 1) +
                            ", columna " + (s.right + 1) + ": " + mensaje);
        } else {
            System.err.println("Error semántico: " + mensaje);
        }
        error_semantic_count++;
    }

:}


terminal INT_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, CHAR_LITERAL;
terminal IF, ELIF, ELSE, WHILE, FOR, DO, BREAK;
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;
terminal INT_MATRIX, FLOAT_MATRIX, STRING_MATRIX, CHAR_MATRIX, BOOLEAN_MATRIX;
terminal ADDITION_ONE, SUBTRACT_ONE, POWERS, ADDITION, SUBTRACT, MULTIPLICATION, DIVISION, MODULE;
terminal CONJUNCTION, DISJUNCTION, DENIAL;
terminal EQ, NEQ, LE, LT, GE, GT;
terminal BRACKET, LBRACKET, RBRACKET, COMMA;
terminal PARENTHESIS_L, PARENTHESIS_R, END_LINE, OPEN_BLOCK, CLOSE_BLOCK;
terminal ASSIGN;
terminal READ_INT, READ_FLOAT, WRITE_INT, WRITE_FLOAT, WRITE_STRING, WRITE_BOOLEAN;
terminal RETURN, COMMENT_BLOCK, COMMENT_LINE, MAIN;
terminal ID, VOID;

// No terminales
non terminal programa, main_func, func_decl, func_list, param_list, param, block;
non terminal stmt_list, stmt, var_decl, assign_stmt, var_decl_asisgn_stmt;
non terminal expr, arith_expr, rel_expr, logic_expr, literal, control_struct;
non terminal if_stmt, if_elif_stmt, if_else_stmt, if_elif_else_stmt, elif_blocks, elif_block;
non terminal do_while_stmt, for_stmt, return_stmt, break_stmt, type, simple_type, matrix_type, comment;
non terminal func_call, arg_list, write_stmt, read_stmt;
non terminal array_decl, array_int_expr, array_int_expr_list, for_expr, for_assign;

precedence left EQ, NEQ, LT, LE, GT, GE;
precedence left ADDITION, SUBTRACT;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence right POWERS;
precedence left PARENTHESIS_L;
precedence left PARENTHESIS_R;
precedence left CONJUNCTION, DISJUNCTION;

start with programa;

programa ::=
    func_list;

main_func ::= VOID MAIN PARENTHESIS_L PARENTHESIS_R
{:
    int row = 0;
    int column = 0;
    createFunction("void", "main", row, column);
    RESULT = null;
:}
    block;

func_decl ::= type:typeFunction ID:name
{:
    if(typeFunction != null && name != null){
        String nameFunction = name.toString();
        String type = typeFunction.toString();
        int row = 0;
        int column = 0;
        createFunction(type, nameFunction, row, column);
        RESULT = null;
    }
:}
    PARENTHESIS_L param_list:params PARENTHESIS_R
{:
    if(params != null){
        String paramsFunction = params.toString();
        String nameFunction = name.toString();
        Function function = Functions.get(nameFunction);
        function.setArguments(paramsFunction);
    }
:}
    block;

func_list ::=
    func_decl func_list
    | comment func_list
    | main_func
    | error ;

param_list ::=
    param:type COMMA param_list:typeList
{:
    if(type != null && typeList != null){
        String types = typeList.toString();
        String typeVar = type.toString();
        RESULT = typeVar + " " + types;
    }
:}
    | param:type
{:
    if(type != null)
        RESULT = type.toString();
:}
    | {:RESULT = null;:};

param ::= type:typeVar ID:name
{:
    if(ActualTable != null && typeVar != null && name != null){
        String nameVar = name.toString();
        String type = typeVar.toString();
        int row = 0;
        int column = 0;
        createVar(type, nameVar, row, column, true);
        RESULT = type;
    }
:};

block ::=
    OPEN_BLOCK
{:
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable);
        ActualTable.AgregarHijo(table);
        ActualTable = table;
    }
:}
    stmt_list
    CLOSE_BLOCK
{:
    if(ActualTable != null)
        ActualTable = ActualTable.getPadre();
:};

stmt_list ::=
    stmt stmt_list
    | stmt;

stmt ::=
    var_decl END_LINE
    | assign_stmt END_LINE
    | var_decl_asisgn_stmt END_LINE
    | control_struct END_LINE
    | control_struct
    | read_stmt END_LINE
    | write_stmt END_LINE
    | return_stmt END_LINE
    | break_stmt END_LINE
    | array_decl END_LINE
    | func_call END_LINE
    | comment
    | error END_LINE;

var_decl ::=
    type:typeVar ID:name
{:
    if(ActualTable != null && typeVar != null && name != null){
        String nameFunction = typeVar.toString();
        String type = name.toString();
        int row = 0;
        int column = 0;
        RESULT = createVar(nameFunction, type, row, column, false);
    }
:};

array_decl ::= 
    type ID LBRACKET expr RBRACKET
    | type ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET
    | matrix_type;

assign_stmt ::=
    ID:name ASSIGN expr
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
    }
:}
    | ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET ASSIGN expr
    | ID LBRACKET expr RBRACKET ASSIGN expr
    | ADDITION_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del ++ con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
        }
    }
:}
    | SUBTRACT_ONE ID:name 
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del -- con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
        }
    }
:};

var_decl_asisgn_stmt ::=
    var_decl:var
{:
    if(ActualTable != null && var != null){
        LineaTabla varLine = (LineaTabla) var;
        if(varLine != null && !ActualTable.setInicializacionDato(varLine.getNombre(), true))
            System.out.println(varLine.getNombre() + " no existe en la linea " +
                varLine.getFila() + " y columna " + varLine.getColumna());
    }
    RESULT = null;
:} ASSIGN expr
    | array_decl:array ASSIGN expr
{:
    if(ActualTable != null && array != null){
        LineaTabla varLine = (LineaTabla) array;
        if(varLine != null && !ActualTable.setInicializacionDato(varLine.getNombre(), true))
            System.out.println(varLine.getNombre() + " no existe en la linea " +
                varLine.getFila() + " y columna " + varLine.getColumna());
    }
    RESULT = null;
:};

expr ::=
    func_call
    | PARENTHESIS_L expr PARENTHESIS_R
    | arith_expr
    | rel_expr
    | logic_expr
    | array_int_expr
    | literal:type
{:
    if(type != null)
        RESULT = type.toString();
:}
    | ID:idDeclarated
{:
    if(ActualTable != null && idDeclarated != null){
        String id = idDeclarated.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        RESULT = line.getTipo();
    }
:}
    | ADDITION_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del ++ con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
            else{
                RESULT = line.getTipo();
            }
        }
    }
:}
    | SUBTRACT_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del -- con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
            else{
                RESULT = line.getTipo();
            }
        }
    }
:};

array_int_expr ::=
    BRACKET array_int_expr_list BRACKET
    | BRACKET BRACKET;

array_int_expr_list ::=
    INT_LITERAL COMMA array_int_expr_list
    | INT_LITERAL;

arith_expr ::= expr:e1 ADDITION expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = (e1.equals("float") || e2.equals("float")) ? "float" : "int";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "no se puede sumar " + e1 + " con " + e2);
        RESULT = "error";
    }
:}
| expr:e1 SUBTRACT expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = (e1.equals("float") || e2.equals("float")) ? "float" : "int";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "no se puede restar " + e1 + " con " + e2);
        RESULT = "error";
    }
:}
| expr:e1 DIVISION expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = "float";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "no se puede dividir " + e1 + " entre " + e2);
        RESULT = "error";
    }
:}
| expr:e1 MULTIPLICATION expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = (e1.equals("float") || e2.equals("float")) ? "float" : "int";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "no se puede multiplicar " + e1 + " con " + e2);
        RESULT = "error";
    }
:}
| expr:e1 POWERS expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = "float";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "no se puede elevar " + e1 + " a " + e2);
        RESULT = "error";
    }
:}
| expr:e1 MODULE expr:e2
{:
    if (e1.equals("int") && e2.equals("int")) {
        RESULT = "int";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "el módulo (%) solo aplica a enteros, recibió " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| SUBTRACT expr:e
{:
    if (e.equals("int") || e.equals("float")) {
        RESULT = e;
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.peek(); // el símbolo actual
        parser.semantic_error(operador, "el signo negativo solo aplica a int o float, recibió " + e);
        RESULT = "error";
    }
:};


rel_expr ::= expr:e1 LT expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "'<' no válido entre " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| expr:e1 LE expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "'<=' no válido entre " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| expr:e1 GT expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "'>' no válido entre " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| expr:e1 GE expr:e2
{:
    if ((e1.equals("int") || e1.equals("float")) && (e2.equals("int") || e2.equals("float"))) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "'>=' no válido entre " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| expr:e1 EQ expr:e2
{:
    if (e1.equals(e2)) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "comparación '==' entre tipos diferentes: " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| expr:e1 NEQ expr:e2
{:
    if (e1.equals(e2)) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "comparación '!=' entre tipos diferentes: " + e1 + " y " + e2);
        RESULT = "error";
    }
:};


logic_expr ::= expr:e1 CONJUNCTION expr:e2
{:
    if (e1.equals("boolean") && e2.equals("boolean")) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "'&&' solo aplica a booleanos, recibió " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| expr:e1 DISJUNCTION expr:e2
{:
    if (e1.equals("boolean") && e2.equals("boolean")) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "'||' solo aplica a booleanos, recibió " + e1 + " y " + e2);
        RESULT = "error";
    }
:}
| DENIAL expr:e
{:
    if (e.equals("boolean")) {
        RESULT = "boolean";
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.peek();
        parser.semantic_error(operador, "negación (!) solo aplica a booleanos, recibió " + e);
        RESULT = "error";
    }
:};

for_expr ::=
    logic_expr
    | rel_expr;

for_assign ::=
    assign_stmt
    | var_decl_asisgn_stmt;

literal ::=
    BOOLEAN_LITERAL {:RESULT = "boolean";:}
    | STRING_LITERAL {:RESULT = "string";:}
    | CHAR_LITERAL {:RESULT = "char";:}
    | FLOAT_LITERAL {:RESULT = "float";:}
    | INT_LITERAL {:RESULT = "int";:};

control_struct ::=
    if_elif_else_stmt
    | if_elif_stmt
    | if_else_stmt
    | if_stmt
    | do_while_stmt
    | for_stmt;

if_elif_else_stmt ::=
    IF PARENTHESIS_L expr PARENTHESIS_R block elif_blocks ELSE block;

if_else_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block ELSE block;

if_elif_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block elif_blocks;

if_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block;

elif_blocks ::=
    elif_block elif_blocks
    | elif_block;

elif_block ::= ELIF PARENTHESIS_L expr PARENTHESIS_R block;

do_while_stmt ::= DO block WHILE PARENTHESIS_L expr PARENTHESIS_R;

for_stmt ::= FOR PARENTHESIS_L for_assign END_LINE for_expr END_LINE assign_stmt PARENTHESIS_R block;

return_stmt ::= RETURN expr;

break_stmt ::= BREAK;

type ::= 
    simple_type:typeString {: RESULT = typeString.toString(); :}
    | matrix_type:typeString {: RESULT = typeString.toString(); :};

simple_type ::=
    INT {:RESULT = "int";:}
    | FLOAT {:RESULT = "float";:}
    | BOOLEAN {:RESULT = "boolean";:}
    | CHAR {:RESULT = "char";:}
    | STRING {:RESULT = "string";:};

matrix_type ::=
    INT_MATRIX {:RESULT = "intMatrix";:}
    | FLOAT_MATRIX {:RESULT = "floatMatrix";:}
    | STRING_MATRIX {:RESULT = "stringMatrix";:}
    | CHAR_MATRIX {:RESULT = "charMatrix";:}
    | BOOLEAN_MATRIX {:RESULT = "booleanMatrix";:};

comment ::= 
    COMMENT_BLOCK
    | COMMENT_LINE;

func_call ::=
    ID:name PARENTHESIS_L arg_list:args PARENTHESIS_R
{:
    if(ActualTable != null && args != null && name != null){
        String nameCall = name.toString();
        String argsCall = args.toString();
        if(Functions.containsKey(nameCall)){
            Function function = Functions.get(nameCall);
            String argsFunction = function.getArguments();
            if(argsFunction.equals(argsCall)){
                RESULT = function.getTipo();
            }
            else{
                System.err.println("Error semántico: La función " + nameCall +
                    " tiene argumentos de tipo |" + argsFunction + "|, en " +
                    " cambio, se enviaron argumentos de tipo |" + argsCall + 
                    "|.");
            }
        }
        else{
            System.err.println("No existe la función " + nameCall + ".");
        }
    }
:}
    | ID:nameFuncArgsEmpty PARENTHESIS_L PARENTHESIS_R
{:
    if(ActualTable != null && nameFuncArgsEmpty != null){
        String nameCall = nameFuncArgsEmpty.toString();
        String argsCall = "";
        if(Functions.containsKey(nameCall)){
            Function function = Functions.get(nameCall);
            String argsFunction = function.getArguments();
            if(argsFunction.equals(argsCall)){
                RESULT = function.getTipo();
            }
            else{
                System.err.println("Error semántico: La función " + nameCall +
                    " tiene argumentos de tipo |" + argsFunction + "|, en " +
                    " cambio, se enviaron argumentos de tipo |" + argsCall + 
                    "|.");
            }
        }
        else{
            System.err.println("No existe la función " + nameCall + ".");
        }
    }
:};

arg_list ::= expr:type COMMA arg_list:types
{:
    if(ActualTable != null && type != null && types != null){
        String typesAux = types.toString();
        String typeAux = type.toString();
        RESULT = typeAux + " " + typesAux;
    }
:}
    | expr:type
{:
    if(ActualTable != null && type != null){
        RESULT = type.toString();
    }
:};

write_stmt ::= 
    WRITE_INT INT_LITERAL 
    | WRITE_INT ID
    | WRITE_FLOAT FLOAT_LITERAL 
    | WRITE_FLOAT ID
    | WRITE_STRING STRING_LITERAL 
    | WRITE_STRING ID
    | WRITE_BOOLEAN BOOLEAN_LITERAL 
    | WRITE_BOOLEAN ID;

read_stmt ::= 
    READ_INT ID
    | READ_FLOAT ID;
