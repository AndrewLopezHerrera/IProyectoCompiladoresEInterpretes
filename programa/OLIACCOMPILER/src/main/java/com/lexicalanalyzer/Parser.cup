package com.lexicalanalyzer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;

parser code {:
    public int error_count = 0;
    public int error_semantic_count = 0;
    private Map<String, Function> Functions = new HashMap<>() ;
    private Map<String, TablaDeSimbolos> FunctionTables = new HashMap<>() ;
    private TablaDeSimbolos ActualTable = null;
    private Function ActualFunction = null;

    // Modificar para que reporte todos los errores
    public void syntax_error(Symbol s) {
        if (s != null) {
            System.out.println("Error sintáctico en la línea " +(s.left + 1) +
            ", columna " + (s.right + 1) + ": " + s.value);
        }
        error_count++;
    }

    public void report_fatal_error(String message, Object info) {
        System.err.println(">>> Error FATAL de análisis sintáctico: " + message);
    }

    public void createFunction(String pTypeReturn, String pName, int pRow, int pColumn){
        if(Functions.containsKey(pName)){
            ActualTable = null;
            ActualFunction = null; 
            System.err.println("Error semántico: La función " + pName + 
                " está duplicada");
            error_semantic_count++;
        }
        else{
            Function function = new Function(pTypeReturn, pName, pRow, pColumn, true);
            ActualFunction = function;
            Functions.put(pName, function);
            TablaDeSimbolos table = new TablaDeSimbolos(null, pName);
            FunctionTables.put(pName, table);
            ActualTable = table;
        }
    }

    public LineaTabla createVar(String pTypeReturn, String pName, int pRow,
        int pColumn, boolean pInitialized){
        LineaTabla line = new LineaTabla(pTypeReturn, pName, pRow,pColumn, pInitialized);
        if(!ActualTable.AgregarDato(line)){
            System.err.println("Error semántico: La variable " + pName + 
                " está duplicada");
            return null;
        }
        return line;
    }

    public void printTables(){
        System.out.println(Functions.toString() + "\n");
        Collection<TablaDeSimbolos> tables = FunctionTables.values();
        for (TablaDeSimbolos table : tables){
            System.out.println(table.toString());
        }
    }

    public void semantic_error(Symbol s, String mensaje) {
        if (s != null) {
            System.err.println("Error semántico en la línea " + (s.left + 1) +
                            ", columna " + (s.right + 1) + ": " + mensaje);
        } else {
            System.err.println("Error semántico: " + mensaje);
        }
        error_semantic_count++;
    }

    List<InstruccionIntermedia> codigoIntermedio = new ArrayList<>();
    int contadorTemporales = 0;

    public String nuevoTemporal() {
        return "t" + (contadorTemporales++);
    }

    public void escribirCodigoIntermedio(String archivo) {
        try (PrintWriter pw = new PrintWriter(new FileWriter(archivo))) {
            for (InstruccionIntermedia inst : codigoIntermedio) {
                pw.println(inst);
            }
        } catch (IOException e) {
            System.err.println("No se pudo escribir el archivo de código intermedio.");
        }
    }

    private int contadorEtiquetas = 0;

    public String nuevaEtiqueta(String base) {
        return "et_" + base + "_" + (contadorEtiquetas++);
    }
:}


terminal INT_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, CHAR_LITERAL;
terminal IF, ELIF, ELSE, WHILE, FOR, DO, BREAK;
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;
terminal INT_MATRIX, FLOAT_MATRIX, STRING_MATRIX, CHAR_MATRIX, BOOLEAN_MATRIX;
terminal ADDITION_ONE, SUBTRACT_ONE, POWERS, ADDITION, SUBTRACT, MULTIPLICATION, DIVISION, MODULE;
terminal CONJUNCTION, DISJUNCTION, DENIAL;
terminal EQ, NEQ, LE, LT, GE, GT;
terminal BRACKET, LBRACKET, RBRACKET, COMMA;
terminal PARENTHESIS_L, PARENTHESIS_R, END_LINE, OPEN_BLOCK, CLOSE_BLOCK;
terminal ASSIGN;
terminal READ_INT, READ_FLOAT, WRITE_INT, WRITE_FLOAT, WRITE_STRING, WRITE_BOOLEAN;
terminal RETURN, COMMENT_BLOCK, COMMENT_LINE, MAIN;
terminal ID, VOID;

// No terminales
non terminal programa, main_func, func_decl, func_list, param_list, param, block;
non terminal stmt_list, stmt, var_decl, assign_stmt, var_decl_asisgn_stmt;
non terminal expr, arith_expr, rel_expr, logic_expr, literal, control_struct;
non terminal if_stmt, if_elif_stmt, if_else_stmt, if_elif_else_stmt, elif_blocks, elif_block;
non terminal do_while_stmt, for_stmt, return_stmt, break_stmt, type, simple_type, matrix_type, comment;
non terminal func_call, arg_list, write_stmt, read_stmt, selection_stmt;
non terminal array_decl, array_int_expr, array_int_expr_list, for_assign;

precedence left EQ, NEQ, LT, LE, GT, GE;
precedence left ADDITION, SUBTRACT;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence right POWERS;
precedence left PARENTHESIS_L;
precedence left PARENTHESIS_R;
precedence left CONJUNCTION, DISJUNCTION;

start with programa;

programa ::=
    func_list;

main_func ::= VOID MAIN PARENTHESIS_L PARENTHESIS_R
{:
    int row = 0;
    int column = 0;
    createFunction("void", "main", row, column);
    RESULT = null;
:}
    block;

func_decl ::= type:typeFunction ID:name
{:
    if(typeFunction != null && name != null){
        String nameFunction = name.toString();
        String type = typeFunction.toString();
        int row = 0;
        int column = 0;
        createFunction(type, nameFunction, row, column);
        RESULT = null;
    }
:}
    PARENTHESIS_L param_list:params PARENTHESIS_R
{:
    if(params != null){
        String paramsFunction = params.toString();
        String nameFunction = name.toString();
        Function function = Functions.get(nameFunction);
        function.setArguments(paramsFunction);
    }
:}
    block;

func_list ::=
    func_decl func_list
    | comment func_list
    | main_func
    | error ;

param_list ::=
    param:type COMMA param_list:typeList
{:
    if(type != null && typeList != null){
        String types = typeList.toString();
        String typeVar = type.toString();
        RESULT = typeVar + " " + types;
    }
:}
    | param:type
{:
    if(type != null)
        RESULT = type.toString();
:}
    | {:RESULT = null;:};

param ::= type:typeVar ID:name
{:
    if(ActualTable != null && typeVar != null && name != null){
        String nameVar = name.toString();
        String type = typeVar.toString();
        int row = 0;
        int column = 0;
        createVar(type, nameVar, row, column, true);
        RESULT = type;
    }
:};

block ::=
    OPEN_BLOCK
{:
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable, ActualTable.getNombre());
        ActualTable.AgregarHijo(table);
        ActualTable = table;
    }
:}
    stmt_list
    CLOSE_BLOCK
{:
    if(ActualTable != null){
        RESULT = ActualTable;
        ActualTable = ActualTable.getPadre();
    }
:};

stmt_list ::=
    stmt stmt_list
    | stmt;

stmt ::=
    var_decl END_LINE
    | assign_stmt END_LINE
    | var_decl_asisgn_stmt END_LINE
    | control_struct END_LINE
    | control_struct
    | read_stmt END_LINE
    | write_stmt END_LINE
    | return_stmt END_LINE
    | break_stmt END_LINE
    | array_decl END_LINE
    | func_call END_LINE
    | comment
    | error END_LINE;

var_decl ::=
    type:typeVar ID:name
{:
    if(ActualTable != null && typeVar != null && name != null){
        String nameFunction = typeVar.toString();
        String type = name.toString();
        int row = 0;
        int column = 0;
        RESULT = createVar(nameFunction, type, row, column, false);
    }
:};

array_decl ::= 
    type ID LBRACKET expr RBRACKET
    | type ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET
    | matrix_type;

assign_stmt ::= 
    ID:name ASSIGN expr:type 
{:
    if (ActualTable != null && name != null && type != null) {
        String id = name.toString();
        String[] tipoValor = (String[]) type; // tipo y valor temporal
        String tipoExpr = tipoValor[0];
        String valorExpr = tipoValor[1];

        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null || !ActualTable.setInicializacionDato(id, true)) {
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe.");
        } else if (!tipoExpr.equals(line.getTipo())) {
            error_semantic_count++;
            System.err.println("Error semántico: no se puede asignar el tipo " +
                tipoExpr + " a la variable " + id + " de tipo " + line.getTipo() + ".");
        } else {
            parser.codigoIntermedio.add(new AsignacionInstr(id, valorExpr));
            if (ActualTable != null) {
                ActualTable.agregarInstruccion(new AsignacionInstr(id, valorExpr));
            }
        }
    }
:}
| ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET ASSIGN expr
{:
    // TODO: Código intermedio para asignación a matriz 2D
    System.err.println("⚠ Asignación a matriz 2D aún no implementada.");
:}
| ID LBRACKET expr RBRACKET ASSIGN expr
{:
    // TODO: Código intermedio para asignación a matriz 1D
    System.err.println(" Asignación a matriz 1D aún no implementada.");
:}
| ADDITION_ONE ID:name 
{:
    if (ActualTable != null && name != null) {
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null) {
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe.");
        } else if (!line.getTipo().equals("int")) {
            error_semantic_count++;
            System.err.println("El operador ++ solo se permite sobre enteros.");
        } else {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, id, "+", "1"));
            parser.codigoIntermedio.add(new AsignacionInstr(id, temp));
            if (ActualTable != null) {
                ActualTable.agregarInstruccion(new OperacionInstr(temp, id, "+", "1"));
                ActualTable.agregarInstruccion(new AsignacionInstr(id, temp));
            }
        }
    }
:}

| SUBTRACT_ONE ID:name 
{:
    if (ActualTable != null && name != null) {
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null) {
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe.");
        } else if (!line.getTipo().equals("int")) {
            error_semantic_count++;
            System.err.println("El operador -- solo se permite sobre enteros.");
        } else if (!line.getEstaInicializado()) {
            error_semantic_count++;
            System.err.println("No se ha inicializado el identificador " + id);
        } else {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, id, "-", "1"));
            parser.codigoIntermedio.add(new AsignacionInstr(id, temp));
        }
    }
:};


var_decl_asisgn_stmt ::= var_decl:var ASSIGN expr:type
{:
    if(ActualTable != null && var != null && type != null){
        String[] tipoValor = (String[]) type; // tipo y valor temporal
        String tipoExpr = tipoValor[0];
        String valorExpr = tipoValor[1];

        LineaTabla line = (LineaTabla) var;
        if(line == null || !ActualTable.setInicializacionDato(line.getNombre(), true)){
            error_semantic_count++;
            System.err.println("El identificador " + line.getNombre() + " no existe");
        }
        else if(!tipoExpr.equals(line.getTipo())){
            error_semantic_count++;
            System.err.println("Error semántico: no se puede asignar el tipo " +
                tipoExpr + " a la variable " + line.getNombre() + " con tipo " +
                line.getTipo() + ".");
        }
        else {
            //Código intermedio para declaración con asignación
            parser.codigoIntermedio.add(new DeclAsigInstr(line.getTipo(), line.getNombre(), valorExpr));
        }
    }
:}
| array_decl:array ASSIGN expr
{:
    if(ActualTable != null && array != null){
        LineaTabla varLine = (LineaTabla) array;
        if(varLine != null && !ActualTable.setInicializacionDato(varLine.getNombre(), true)){
            System.err.println(varLine.getNombre() + " no existe en la linea " +
                varLine.getFila() + " y columna " + varLine.getColumna());
            error_semantic_count++;
        }
    }
    RESULT = null;
:};


expr ::=
    func_call:type
{:
    if(type != null)
        RESULT = type;
:}
    | PARENTHESIS_L expr:type PARENTHESIS_R
{:
    if(type != null)
        RESULT = type;
:}
    | arith_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | rel_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | logic_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | array_int_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | literal:type
{:
    if(type != null)
        RESULT = type;
:}
    | ID:idDeclarated
{:
    if (ActualTable != null && idDeclarated != null) {
        String id = idDeclarated.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null) {
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        } else if (!line.getEstaInicializado()) {
            error_semantic_count++;
            System.err.println("No se ha inicializado el identificador " + id);
        } else {
            RESULT = new String[] { line.getTipo(), id };
        }
    }
:}

    | ADDITION_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del ++ con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
            else if(!line.getEstaInicializado()){
                System.err.println("No se ha inicializado el identificador " +
                    line.getNombre());
                error_semantic_count++;
            }
            else{
                RESULT = new String[] {line.getTipo(), id};
            }
        }
    }
:}
    | SUBTRACT_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del -- con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
            else if(!line.getEstaInicializado()){
                System.err.println("No se ha inicializado el identificador " +
                    line.getNombre());
                error_semantic_count++;
            }
            else{
                RESULT = new String[] {line.getTipo(), id};
            }
        }
    }
:};

array_int_expr ::=
    BRACKET array_int_expr_list BRACKET
    | BRACKET BRACKET;

array_int_expr_list ::=
    INT_LITERAL COMMA array_int_expr_list
    | INT_LITERAL;

arith_expr ::=
    expr:e1 ADDITION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "+", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede sumar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 SUBTRACT expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "-", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede restar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 MULTIPLICATION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "*", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede multiplicar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 POWERS expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "*", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede multiplicar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 DIVISION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "/", val2));

            RESULT = new String[] {
                "float", // División siempre se trata como flotante
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede dividir " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 MODULE expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            tipo1.equals("int") && tipo2.equals("int")) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "%", val2));

            RESULT = new String[] { "int", temp };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "el operador módulo sólo se permite entre enteros");
            RESULT = new String[] { "error", "" };
        }
    }
:}
| SUBTRACT expr:e
{:
    String[] v = (String[]) e;
    if(ActualTable != null && e != null){
        String tipo = v[0];
        String val = v[1];

        if (ActualTable != null && e != null &&
            (tipo.equals("int") || tipo.equals("float"))) {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, "-", val, ""));
            RESULT = new String[] { tipo, temp };
        } else {
            parser.semantic_error(null, "el operador unario '-' solo se permite para enteros o flotantes");
            RESULT = new String[] { "error", "" };
        }
    }
:};


rel_expr ::= expr:e1 LT expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "<", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'<' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 LE expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "<=", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'<=' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 GT expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, ">", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'>' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 GE expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, ">=", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'>=' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 EQ expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];
        if (tipo1.equals(tipo2)) {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "==", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "comparación '==' entre tipos diferentes: " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 NEQ expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (tipo1.equals(tipo2)) {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "!=", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "comparación '!=' entre tipos diferentes: " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:};


logic_expr ::= expr:e1 CONJUNCTION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;

    if (ActualTable != null && e1 != null && e2 != null &&
        v1[0].equals("boolean") && v2[0].equals("boolean")) {
        String temp = parser.nuevoTemporal();
        parser.codigoIntermedio.add(new OperacionInstr(temp, v1[1], "&&", v2[1]));
        RESULT = new String[] { "boolean", temp };
    } else {
        parser.semantic_error(null, "'&&' solo aplica a booleanos, recibió " + v1[0] + " y " + v2[0]);
        RESULT = new String[] { "error", "" };
    }
:}
| expr:e1 DISJUNCTION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;

    if (ActualTable != null && e1 != null && e2 != null &&
        v1[0].equals("boolean") && v2[0].equals("boolean")) {
        String temp = parser.nuevoTemporal();
        parser.codigoIntermedio.add(new OperacionInstr(temp, v1[1], "||", v2[1]));
        RESULT = new String[] { "boolean", temp };
    } else {
        parser.semantic_error(null, "'||' solo aplica a booleanos, recibió " + v1[0] + " y " + v2[0]);
        RESULT = new String[] { "error", "" };
    }
:}
| DENIAL expr:e
{:
    String[] v = (String[]) e;

    if (ActualTable != null && e != null && v[0].equals("boolean")) {
        String temp = parser.nuevoTemporal();
        parser.codigoIntermedio.add(new OperacionUnariaInstr(temp, "!", v[1]));
        RESULT = new String[] { "boolean", temp };
    } else {
        parser.semantic_error(null, "negación (!) solo aplica a booleanos, recibió " + v[0]);
        RESULT = new String[] { "error", "" };
    }
:};


for_assign ::=
    assign_stmt
    | var_decl_asisgn_stmt;

literal ::= INT_LITERAL:n
{:
    RESULT = new String[] { "int", n.toString() };
:}
| FLOAT_LITERAL:n
{:
    RESULT = new String[] { "float", n.toString() };
:}
| BOOLEAN_LITERAL:n
{:
    RESULT = new String[] { "boolean", n.toString() };
:}
| STRING_LITERAL:n
{:
    RESULT = new String[] { "string", n.toString() };
:}
| CHAR_LITERAL:n
{:
    RESULT = new String[] { "char", n.toString() };
:};

control_struct ::=
    if_elif_else_stmt
    | if_elif_stmt
    | if_else_stmt
    | if_stmt
    | selection_stmt
    | do_while_stmt
    | for_stmt;

if_elif_else_stmt ::=
    IF PARENTHESIS_L expr:type PARENTHESIS_R block:tableIf
    elif_blocks ELSE block:tableElse
{:
    if(ActualTable != null && tableElse != null && type != null && tableIf != null){
        String typeExpr = tableIf.toString();
        if(!typeExpr.equals("boolean")){
            System.err.println("Error semántico: if necesita una " +
                "expresion de tipo booleano para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr + ".");
            error_semantic_count++;
        }
        TablaDeSimbolos tableAuxIf = (TablaDeSimbolos) tableIf;
        tableAuxIf.setNombre("elif");
        TablaDeSimbolos tableAuxElse = (TablaDeSimbolos) tableElse;
        tableAuxElse.setNombre("else");
    }
:};

if_else_stmt ::= 
    IF PARENTHESIS_L expr:cond PARENTHESIS_R block:blockIf
    ELSE block:blockElse
{:
    if (ActualTable != null && cond != null && blockIf != null && blockElse != null) {
        String[] condicion = (String[]) cond;
        String tempCond = condicion[1];

        String etiquetaElse = parser.nuevaEtiqueta("if_else");
        String etiquetaFin = parser.nuevaEtiqueta("if_fin");

        // Etiqueta condicional
        parser.codigoIntermedio.add(new IfFalseInstr(tempCond, etiquetaElse));

        // Instrucciones del bloque IF
        if (blockIf instanceof TablaDeSimbolos tablaIf) {
            tablaIf.setNombre("if");
            for (InstruccionIntermedia inst : tablaIf.getInstrucciones()) {
                parser.codigoIntermedio.add(inst);
            }
        }

        // Salto al final
        parser.codigoIntermedio.add(new GotoInstr(etiquetaFin));

        // Etiqueta ELSE
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquetaElse));
        if (blockElse instanceof TablaDeSimbolos tablaElse) {
            tablaElse.setNombre("else");
            for (InstruccionIntermedia inst : tablaElse.getInstrucciones()) {
                parser.codigoIntermedio.add(inst);
            }
        }

        // Etiqueta final
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquetaFin));
    }
:};


if_elif_stmt ::= 
    IF PARENTHESIS_L expr:type PARENTHESIS_R block:table
    elif_blocks
{:
    if(ActualTable != null && table != null && type != null){
        String typeExpr = type.toString();
        if(!typeExpr.equals("boolean")){
            System.err.println("Error semántico: if necesita una " +
                "expresion de tipo booleano para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr + ".");
            error_semantic_count++;
        }
        TablaDeSimbolos tableAux = (TablaDeSimbolos) table;
        tableAux.setNombre("if");
    }
:};

selection_stmt ::= IF expr:cond OPEN_BLOCK stmt_list:ifbody CLOSE_BLOCK
{:
    if(ActualTable != null && cond != null && ifbody != null){
        String[] condicion = (String[]) cond;
        String tempCond = condicion[1];

        String etiquetaFin = parser.nuevaEtiqueta("finIF");

        parser.codigoIntermedio.add(new IfFalseInstr(tempCond, etiquetaFin));
        parser.codigoIntermedio.addAll((List<InstruccionIntermedia>) ifbody);
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquetaFin));
    }
:}
| IF expr:cond OPEN_BLOCK stmt_list:ifbody CLOSE_BLOCK ELSE OPEN_BLOCK stmt_list:elsebody CLOSE_BLOCK
{:
    if(ActualTable != null && cond != null && ifbody != null && elsebody != null){
        String[] condicion = (String[]) cond;
        String tempCond = condicion[1];

        String etiquetaElse = parser.nuevaEtiqueta("inicioElse");
        String etiquetaFin = parser.nuevaEtiqueta("finElse");

        parser.codigoIntermedio.add(new IfFalseInstr(tempCond, etiquetaElse));
        parser.codigoIntermedio.addAll((List<InstruccionIntermedia>) ifbody);
        parser.codigoIntermedio.add(new GotoInstr(etiquetaFin));
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquetaElse));
        parser.codigoIntermedio.addAll((List<InstruccionIntermedia>) elsebody);
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquetaFin));
    }
:};


if_stmt ::= 
    IF PARENTHESIS_L expr:cond PARENTHESIS_R block:blockIf
{:
    if (ActualTable != null && cond != null) {
        String[] condicion = (String[]) cond;
        String tempCond = condicion[1];

        String etiquetaFin = parser.nuevaEtiqueta("if_fin");

        parser.codigoIntermedio.add(new IfFalseInstr(tempCond, etiquetaFin));

        if (blockIf instanceof TablaDeSimbolos tablaIf) {
            tablaIf.setNombre("if");
            for (InstruccionIntermedia inst : tablaIf.getInstrucciones()) {
                parser.codigoIntermedio.add(inst);
            }
        }

        parser.codigoIntermedio.add(new EtiquetaInstr(etiquetaFin));
    }
:};



elif_blocks ::=
    elif_block elif_blocks
    | elif_block;

elif_block ::=
    ELIF PARENTHESIS_L expr:type PARENTHESIS_R block:table
{:
    if(ActualTable != null && table != null && type != null){
        String typeExpr = type.toString();
        if(!typeExpr.equals("boolean")){
            System.err.println("Error semántico: elif necesita una " +
                "expresion de tipo booleano para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr + ".");
            error_semantic_count++;
        }
        TablaDeSimbolos tableAux = (TablaDeSimbolos) table;
        tableAux.setNombre("elif");
    }
:};

do_while_stmt ::=
    DO
{:
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable, "do-while");
        ActualTable.AgregarHijo(table);
        ActualTable = table;
    }
:}
    block WHILE PARENTHESIS_L expr:type PARENTHESIS_R
{:
    if(ActualTable != null && type != null){
        ActualTable = ActualTable.getPadre();
        String[] typeExpr = (String[]) type;
        if(!typeExpr[0].equals("boolean")){
            System.err.println("Error semántico: do-while necesita una " +
                "expresion de tipo booleano para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr[0] + ".");
            error_semantic_count++;
        }
    }
:};

for_stmt ::=
    FOR
{:
    String etiquedaInicio = null;
    String etiquedaIntermedia = null;
    String etiquetaFin = null;
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable, "for");
        ActualTable.AgregarHijo(table);
        ActualTable = table;
        etiquedaInicio = nuevaEtiqueta("for_inicio");
        etiquedaIntermedia = nuevaEtiqueta("for_intermedio");
        etiquetaFin = nuevaEtiqueta("for_final");
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaInicio));
    }
:}
    PARENTHESIS_L for_assign END_LINE expr:type END_LINE

    assign_stmt PARENTHESIS_R block
{:
    if(ActualTable != null && type != null){
        ActualTable = ActualTable.getPadre();
        String[] typeExpr = (String[]) type;
        if(!typeExpr[0].equals("boolean")){
            System.err.println("Error semántico: for necesita una " +
                "expresion de tipo booleano para en su segundo parámetro para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr[0] + ".");
            error_semantic_count++;
        }
    }
:};

return_stmt ::= RETURN expr:type
{:
    if(ActualTable != null && type != null){
        String[] typeReturn = (String[]) type;
        if(!typeReturn[0].equals(ActualFunction.getTipo())){
            System.err.println("Error semántico: El valor retornado " +
                typeReturn + " no corresponde con el tipo de retorno " +
                ActualFunction.getTipo() + " de la funcion " +
                ActualFunction.getNombre() + ".");
            error_semantic_count++;
        }
    }
:};

break_stmt ::= BREAK
{:
    if(ActualTable != null){
        TablaDeSimbolos actualTable = ActualTable;
        while (actualTable != null){
            if(ActualTable.getNombre().equals("for")
                || ActualTable.getNombre().equals("do-while"))
                break;
            actualTable = actualTable.getPadre();
        }
        if(actualTable == null){
            System.err.println("Error semántico: El BREAK solo puede utilizarse"
                + " dentro de iteradores for o do-while");
            error_semantic_count++;
        }
    }
:};

type ::= 
    simple_type:typeString {: RESULT = typeString.toString(); :}
    | matrix_type:typeString {: RESULT = typeString.toString(); :};

simple_type ::=
    INT {:RESULT = "int";:}
    | FLOAT {:RESULT = "float";:}
    | BOOLEAN {:RESULT = "boolean";:}
    | CHAR {:RESULT = "char";:}
    | STRING {:RESULT = "string";:};

matrix_type ::=
    INT_MATRIX {:RESULT = "intMatrix";:}
    | FLOAT_MATRIX {:RESULT = "floatMatrix";:}
    | STRING_MATRIX {:RESULT = "stringMatrix";:}
    | CHAR_MATRIX {:RESULT = "charMatrix";:}
    | BOOLEAN_MATRIX {:RESULT = "booleanMatrix";:};

comment ::= 
    COMMENT_BLOCK
    | COMMENT_LINE;

func_call ::=
    ID:name PARENTHESIS_L arg_list:args PARENTHESIS_R
{:
    if(ActualTable != null && args != null && name != null){
        String nameCall = name.toString();
        String argsCall = args.toString();
        if(Functions.containsKey(nameCall)){
            Function function = Functions.get(nameCall);
            String argsFunction = function.getArguments();
            if(argsFunction.equals(argsCall)){
                RESULT = new String[] {function.getTipo(), nameCall};
            }
            else{
                System.err.println("Error semántico: La función " + nameCall +
                    " tiene argumentos de tipo |" + argsFunction + "|, en " +
                    " cambio, se enviaron argumentos de tipo |" + argsCall + 
                    "|.");
            }
        }
        else{
            System.err.println("No existe la función " + nameCall + ".");
        }
    }
:}
    | ID:name PARENTHESIS_L PARENTHESIS_R
{:
    if(ActualTable != null && name != null){
        String nameCall = name.toString();
        String argsCall = "";
        if(Functions.containsKey(nameCall)){
            Function function = Functions.get(nameCall);
            String argsFunction = function.getArguments();
            if(argsFunction.equals(argsCall)){
                RESULT = new String[] {function.getTipo(), nameCall};
            }
            else{
                System.err.println("Error semántico: La función " + nameCall +
                    " tiene argumentos de tipo |" + argsFunction + "|, en " +
                    " cambio, se enviaron argumentos de tipo |" + argsCall + 
                    "|.");
            }
        }
        else{
            System.err.println("No existe la función " + nameCall + ".");
        }
    }
:};

arg_list ::= expr:type COMMA arg_list:types
{:
    if(ActualTable != null && type != null && types != null){
        String typesAux = types.toString();
        String[] typeAux = (String[]) type;
        RESULT = typeAux[0] + " " + typesAux;
    }
:}
    | expr:type
{:
    if(ActualTable != null && type != null){
        String[] typeAux = (String[]) type;
        RESULT = typeAux[0];

    }
:};

write_stmt ::= 
    WRITE_INT INT_LITERAL 
    | WRITE_INT ID:name
{:
    if(ActualTable != null && name == null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            System.err.println("Error semántico: El identificador " +
                id + " no existe");
            error_semantic_count++;
        }
        else if(!line.getEstaInicializado()){
            System.err.println("No se ha inicializado el identificador " +
                line.getNombre());
            error_semantic_count++;
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("Error semántico: El identificador debe ser"
                    + " de tipo entero");
                error_semantic_count++;
            }   
        }
    }
:}
    | WRITE_FLOAT FLOAT_LITERAL 
    | WRITE_FLOAT ID:name
{:
    if(ActualTable != null && name == null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            System.err.println("Error semántico: El identificador " +
                id + " no existe");
            error_semantic_count++;
        }
        else if(!line.getEstaInicializado()){
            System.err.println("No se ha inicializado el identificador " +
                line.getNombre());
            error_semantic_count++;
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("Error semántico: El identificador debe ser"
                    + " de tipo flotante");
                error_semantic_count++;
            }   
        }
    }
:}
    | WRITE_STRING STRING_LITERAL 
    | WRITE_STRING ID:name
{:
    if(ActualTable != null && name == null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            System.err.println("Error semántico: El identificador " +
                id + " no existe");
            error_semantic_count++;
        }
        else if(!line.getEstaInicializado()){
            System.err.println("No se ha inicializado el identificador " +
                line.getNombre());
            error_semantic_count++;
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("Error semántico: El identificador debe ser"
                    + " de tipo string");
                error_semantic_count++;
            }   
        }
    }
:}
    | WRITE_BOOLEAN BOOLEAN_LITERAL 
    | WRITE_BOOLEAN ID:name
{:
    if(ActualTable != null && name == null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            System.err.println("Error semántico: El identificador " +
                id + " no existe");
            error_semantic_count++;
        }
        else if(!line.getEstaInicializado()){
            System.err.println("No se ha inicializado el identificador " +
                line.getNombre());
            error_semantic_count++;
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("Error semántico: El identificador debe ser"
                    + " de tipo booleano");
                error_semantic_count++;
            }   
        }
    }
:};

read_stmt ::= 
    READ_INT ID:name
{:
    if(ActualTable != null && name == null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            System.err.println("Error semántico: El identificador " +
                id + " no existe");
            error_semantic_count++;
        }
        else if(!line.getEstaInicializado()){
            System.err.println("No se ha inicializado el identificador " +
                line.getNombre());
            error_semantic_count++;
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("Error semántico: El identificador debe ser"
                    + " de tipo entero");
                error_semantic_count++;
            }   
        }
    }
:}
    | READ_FLOAT ID:name
{:
    if(ActualTable != null && name == null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            System.err.println("Error semántico: El identificador " +
                id + " no existe");
            error_semantic_count++;
        }
        else if(!line.getEstaInicializado()){
            System.err.println("No se ha inicializado el identificador " +
                line.getNombre());
            error_semantic_count++;
        }
        else{
            if(!line.getTipo().equals("float")){
                System.err.println("Error semántico: El identificador debe ser"
                    + " de tipo flotante");
                error_semantic_count++;
            }   
        }
    }
:};