package com.lexicalanalyzer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;

parser code {:
    public int error_count = 0;
    public int error_semantic_count = 0;
    private Map<String, LineaTabla> Functions = new HashMap<>() ;
    private Map<String, TablaDeSimbolos> FunctionTables = new HashMap<>() ;
    private TablaDeSimbolos ActualTable = null;

    // Modificar para que reporte todos los errores
    public void syntax_error(Symbol s) {
        if (s != null) {
            System.out.println("Error sintáctico en la línea " +(s.left + 1) +
            ", columna " + (s.right + 1) + ": " + s.value);
        }
        error_count++;
    }

    public void report_fatal_error(String message, Object info) {
        System.err.println(">>> Error FATAL de análisis sintáctico: " + message);
    }

    public void createFunction(String pTypeReturn, String pName, int pRow, int pColumn){
        if(Functions.containsKey(pName)){
            ActualTable = null;
            error_semantic_count++;
        }
        else{
            LineaTabla function = new LineaTabla(pTypeReturn, pName, pRow, pColumn, true);
            Functions.put(pName, function);
            TablaDeSimbolos table = new TablaDeSimbolos(null);
            FunctionTables.put(pName, table);
            ActualTable = table;
        }
    }

    public LineaTabla createVar(String pTypeReturn, String pName, int pRow,
        int pColumn, boolean pInitialized){
        LineaTabla line = new LineaTabla(pTypeReturn, pName, pRow,pColumn, pInitialized);
        if(!ActualTable.AgregarDato(line)){
            System.err.println("Error sintáctico en la línea: Ya existe " + pName
                +". Por lo tanto debe cambiar el nombre de " + pName +
                " en la línea " + pRow + " y columna " + pColumn);
            error_semantic_count++;
            return null;
        }
        return line;
    }

    public void printTables(){
        Collection<TablaDeSimbolos> tables = FunctionTables.values();
        for (TablaDeSimbolos table : tables){
            System.out.println(table.toString());
        }
    }
:}


terminal INT_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, CHAR_LITERAL;
terminal IF, ELIF, ELSE, WHILE, FOR, DO, BREAK;
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;
terminal INT_MATRIX, FLOAT_MATRIX, STRING_MATRIX, CHAR_MATRIX, BOOLEAN_MATRIX;
terminal ADDITION_ONE, SUBTRACT_ONE, POWERS, ADDITION, SUBTRACT, MULTIPLICATION, DIVISION, MODULE;
terminal CONJUNCTION, DISJUNCTION, DENIAL;
terminal EQ, NEQ, LE, LT, GE, GT;
terminal BRACKET, LBRACKET, RBRACKET, COMMA;
terminal PARENTHESIS_L, PARENTHESIS_R, END_LINE, OPEN_BLOCK, CLOSE_BLOCK;
terminal ASSIGN;
terminal READ_INT, READ_FLOAT, WRITE_INT, WRITE_FLOAT, WRITE_STRING, WRITE_BOOLEAN;
terminal RETURN, COMMENT_BLOCK, COMMENT_LINE, MAIN;
terminal ID, VOID;

// No terminales
non terminal programa, main_func, func_decl, func_list, param_list, param, block;
non terminal stmt_list, stmt, var_decl, assign_stmt, var_decl_asisgn_stmt;
non terminal expr, arith_expr, rel_expr, logic_expr, literal, control_struct;
non terminal if_stmt, if_elif_stmt, if_else_stmt, if_elif_else_stmt, elif_blocks, elif_block;
non terminal do_while_stmt, for_stmt, return_stmt, break_stmt, type, simple_type, matrix_type, comment;
non terminal func_call, arg_list, write_stmt, read_stmt;
non terminal array_decl, array_int_expr, array_int_expr_list, for_expr, for_assign;

precedence left EQ, NEQ, LT, LE, GT, GE;
precedence left ADDITION, SUBTRACT;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence right POWERS;
precedence left PARENTHESIS_L;
precedence left PARENTHESIS_R;
precedence left CONJUNCTION, DISJUNCTION;

start with programa;

programa ::=
    func_list;

main_func ::= VOID MAIN PARENTHESIS_L PARENTHESIS_R
{:
    int row = 0;
    int column = 0;
    createFunction("void", "main", row, column);
    RESULT = null;
:}
    block;

func_decl ::= type:typeFunction ID:name
{:
    String nameFunction = name.toString();
    String type = typeFunction.toString();
    int row = 0;
    int column = 0;
    createFunction(type, nameFunction, row, column);
    RESULT = null;
:}
    PARENTHESIS_L param_list PARENTHESIS_R block;

func_list ::=
    func_decl func_list
    | comment func_list
    | main_func
    | error ;

param_list ::=
    param COMMA param_list
    | param
    | ;

param ::= type:typeVar ID:name
{:
    if(ActualTable != null){
        String nameVar = name.toString();
        String type = typeVar.toString();
        int row = 0;
        int column = 0;
        createVar(type, nameVar, row, column, true);
        RESULT = null;
    }
:};

block ::=
    OPEN_BLOCK
{:
    TablaDeSimbolos table = new TablaDeSimbolos(ActualTable);
    ActualTable.AgregarHijo(table);
    ActualTable = table;
    
:}
    stmt_list
    CLOSE_BLOCK
{:
    ActualTable = ActualTable.getPadre();
:};

stmt_list ::=
    stmt stmt_list
    | stmt;

stmt ::=
    var_decl END_LINE
    | assign_stmt END_LINE
    | var_decl_asisgn_stmt END_LINE
    | control_struct END_LINE
    | control_struct
    | read_stmt END_LINE
    | write_stmt END_LINE
    | return_stmt END_LINE
    | break_stmt END_LINE
    | array_decl END_LINE
    | func_call END_LINE
    | comment
    | error END_LINE;

var_decl ::=
    type:typeVar ID:name
{:
    if(ActualTable != null){
        String nameFunction = typeVar.toString();
        String type = name.toString();
        int row = 0;
        int column = 0;
        RESULT = createVar(nameFunction, type, row, column, false);
    }
:};

array_decl ::= 
    type ID LBRACKET expr RBRACKET
    | type ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET
    | matrix_type;

assign_stmt ::=
    ID:name ASSIGN expr
{:
    if(ActualTable != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
    }
:}
    | ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET ASSIGN expr
    | ID LBRACKET expr RBRACKET ASSIGN expr
    | ADDITION_ONE ID:name
{:
    if(ActualTable != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del ++ con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
        }
    }
:}
    | SUBTRACT_ONE ID:name 
{:
    if(ActualTable != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del -- con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
        }
    }
:};

var_decl_asisgn_stmt ::=
    var_decl:var
{:
    if(ActualTable != null ){
        LineaTabla varLine = (LineaTabla) var;
        if(varLine != null && !ActualTable.setInicializacionDato(varLine.getNombre(), true))
            System.out.println(varLine.getNombre() + " no existe en la linea " +
                varLine.getFila() + " y columna " + varLine.getColumna());
    }
    RESULT = null;
:} ASSIGN expr
    | array_decl:array ASSIGN expr
{:
    if(ActualTable != null){
        LineaTabla varLine = (LineaTabla) array;
        if(varLine != null && !ActualTable.setInicializacionDato(varLine.getNombre(), true))
            System.out.println(varLine.getNombre() + " no existe en la linea " +
                varLine.getFila() + " y columna " + varLine.getColumna());
    }
    RESULT = null;
:};

expr ::=
    func_call
    | PARENTHESIS_L expr PARENTHESIS_R
    | arith_expr
    | rel_expr
    | logic_expr
    | array_int_expr
    | literal:type
{:
    RESULT = type.toString();
:}
    | ID:idDeclarated
{:
    if(ActualTable != null){
        String id = idDeclarated.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        RESULT = line;
    }
:}
    | ADDITION_ONE ID:name
{:
    if(ActualTable != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del ++ con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
        }
    }
:}
    | SUBTRACT_ONE ID:name
{:
    if(ActualTable != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            error_semantic_count++;
            System.err.println("El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                System.err.println("No se permite el uso del -- con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
                error_semantic_count++;
            }
        }
    }
:};

array_int_expr ::=
    BRACKET array_int_expr_list BRACKET
    | BRACKET BRACKET;

array_int_expr_list ::=
    INT_LITERAL COMMA array_int_expr_list
    | INT_LITERAL;

arith_expr ::=
    expr ADDITION expr
    | expr SUBTRACT expr
    | expr DIVISION expr
    | expr MULTIPLICATION expr
    | expr POWERS expr
    | expr MODULE expr
    | SUBTRACT expr;

rel_expr ::=
    expr LT expr
    | expr LE expr
    | expr GT expr
    | expr GE expr
    | expr EQ expr
    | expr NEQ expr;

logic_expr ::= expr CONJUNCTION expr | expr DISJUNCTION expr | DENIAL expr;

for_expr ::=
    logic_expr
    | rel_expr;

for_assign ::=
    assign_stmt
    | var_decl_asisgn_stmt;

literal ::=
    BOOLEAN_LITERAL {:RESULT = "boolean";:}
    | STRING_LITERAL {:RESULT = "string";:}
    | CHAR_LITERAL {:RESULT = "char";:}
    | FLOAT_LITERAL {:RESULT = "float";:}
    | INT_LITERAL {:RESULT = "int";:};

control_struct ::=
    if_elif_else_stmt
    | if_elif_stmt
    | if_else_stmt
    | if_stmt
    | do_while_stmt
    | for_stmt;

if_elif_else_stmt ::=
    IF PARENTHESIS_L expr PARENTHESIS_R block elif_blocks ELSE block;

if_else_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block ELSE block;

if_elif_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block elif_blocks;

if_stmt ::= IF PARENTHESIS_L expr PARENTHESIS_R block;

elif_blocks ::=
    elif_block elif_blocks
    | elif_block;

elif_block ::= ELIF PARENTHESIS_L expr PARENTHESIS_R block;

do_while_stmt ::= DO block WHILE PARENTHESIS_L expr PARENTHESIS_R;

for_stmt ::= FOR PARENTHESIS_L for_assign END_LINE for_expr END_LINE assign_stmt PARENTHESIS_R block;

return_stmt ::= RETURN expr;

break_stmt ::= BREAK;

type ::= 
    simple_type:typeString {: RESULT = typeString.toString(); :}
    | matrix_type:typeString {: RESULT = typeString.toString(); :};

simple_type ::=
    INT {:RESULT = "int";:}
    | FLOAT {:RESULT = "float";:}
    | BOOLEAN {:RESULT = "boolean";:}
    | CHAR {:RESULT = "char";:}
    | STRING {:RESULT = "string";:};

matrix_type ::=
    INT_MATRIX {:RESULT = "intMatrix";:}
    | FLOAT_MATRIX {:RESULT = "floatMatrix";:}
    | STRING_MATRIX {:RESULT = "stringMatrix";:}
    | CHAR_MATRIX {:RESULT = "charMatrix";:}
    | BOOLEAN_MATRIX {:RESULT = "booleanMatrix";:};

comment ::= 
    COMMENT_BLOCK
    | COMMENT_LINE;

func_call ::=
    ID PARENTHESIS_L arg_list PARENTHESIS_R
    | ID PARENTHESIS_L PARENTHESIS_R;

arg_list ::= expr COMMA arg_list
    | expr;

write_stmt ::= 
    WRITE_INT INT_LITERAL 
    | WRITE_INT ID
    | WRITE_FLOAT FLOAT_LITERAL 
    | WRITE_FLOAT ID
    | WRITE_STRING STRING_LITERAL 
    | WRITE_STRING ID
    | WRITE_BOOLEAN BOOLEAN_LITERAL 
    | WRITE_BOOLEAN ID;

read_stmt ::= 
    READ_INT ID
    | READ_FLOAT ID;
