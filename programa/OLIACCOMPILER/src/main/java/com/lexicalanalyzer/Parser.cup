package com.lexicalanalyzer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Collection;
import java.io.PrintWriter;
import java.io.FileWriter;
import java.io.IOException;

parser code {:
    // Contador de errores sintacticos
    public int error_count = 0;

    // Contador de errores semanticos
    public int error_semantic_count = 0;

    // Mapa de funciones declaradas en el programa
    private Map<String, Function> Functions = new HashMap<>();

    // Mapa de tablas de simbolos por cada funcion
    private Map<String, TablaDeSimbolos> FunctionTables = new HashMap<>();

    // Tabla de simbolos actual en uso
    private TablaDeSimbolos ActualTable = null;

    // Funcion actual en procesamiento
    private Function ActualFunction = null;

    //Pila de las instrucciones iterables que se han creado
    private List<EtiquetaEstructura> PilaIteradores = new ArrayList<>();

    private List<EtiquetaEstructura> PilaControl = new ArrayList<>();

    /**
     * Maneja errores sintacticos encontrados por el parser
     * @param s simbolo donde ocurrio el error
     */
    public void syntax_error(Symbol s) {
        if (s != null) {
            System.out.println("Error sintactico en la linea " + (s.left + 1) +
            ", columna " + (s.right + 1) + ": " + s.value);
        }
        error_count++;
    }

    private int currentLine(){
        return ((MiLexer)super.getScanner()).getLine();
    }

    /**
     * Reporta un error fatal durante el analisis sintactico
     * @param message descripcion del error
     * @param info objeto relacionado con el error
     */
    public void report_fatal_error(String message, Object info) {
        System.err.println(">>> Error FATAL de analisis sintactico: " + message);
    }

    /**
     * Crea una nueva funcion y su tabla de simbolos si no esta duplicada
     * @param pTypeReturn tipo de retorno de la funcion
     * @param pName nombre de la funcion
     * @param pRow fila de declaracion
     * @param pColumn columna de declaracion
     */
    public Function createFunction(String pTypeReturn, String pName, int pRow, int pColumn){
        if(Functions.containsKey(pName)){
            ActualTable = null;
            ActualFunction = null;
            return null;
        }
        else{
            Function function = new Function(pTypeReturn, pName, pRow, pColumn, true);
            ActualFunction = function;
            Functions.put(pName, function);
            TablaDeSimbolos table = new TablaDeSimbolos(null, pName);
            FunctionTables.put(pName, table);
            ActualTable = table;
            return function;
        }
    }

    /**
     * Crea y agrega una variable a la tabla de simbolos actual
     * @param pTypeReturn tipo de dato
     * @param pName nombre de la variable
     * @param pRow fila de declaracion
     * @param pColumn columna de declaracion
     * @param pInitialized indica si esta inicializada
     * @return objeto LineaTabla si fue agregado correctamente, null si ya existe
     */
    public LineaTabla createVar(String pTypeReturn, String pName, int pRow, int pColumn, boolean pInitialized){
        LineaTabla line = new LineaTabla(pTypeReturn, pName, pRow, pColumn, pInitialized);
        if(!ActualTable.AgregarDato(line)){
            return null;
        }
        return line;
    }

    // Imprime todas las funciones y sus respectivas tablas de simbolos
    public void printTables(){
        System.out.println(Functions.toString() + "\n");
        Collection<TablaDeSimbolos> tables = FunctionTables.values();
        for (TablaDeSimbolos table : tables){
            System.out.println(table.toString());
        }
    }

    /**
     * Reporta un error semantico con o sin ubicacion
     * @param s simbolo donde ocurrio el error (puede ser null)
     * @param mensaje descripcion del error
     */
    public void semantic_error(Symbol s, String mensaje) {
        if (s != null) {
            System.err.println("Error semantico en la linea " + (s.left + 1) +
                            ", columna " + (s.right + 1) + ": " + mensaje);
        } else {
            System.err.println("Error semantico en la línea " + currentLine() + ": " + mensaje);
        }
        error_semantic_count++;
    }

    // Lista de instrucciones intermedias generadas por el parser
    List<InstruccionIntermedia> codigoIntermedio = new ArrayList<>();

    // Contador para generar nombres unicos de temporales
    int contadorTemporales = 0;

    /**
     * Genera un nuevo nombre de temporal
     * @return nombre del temporal generado (ej: t0, t1...)
     */
    public String nuevoTemporal() {
        return "t" + (contadorTemporales++);
    }

    /**
     * Escribe las instrucciones intermedias en un archivo
     * @param archivo nombre del archivo de salida
     */
    public void escribirCodigoIntermedio(String archivo) {
        try (PrintWriter pw = new PrintWriter(new FileWriter(archivo))) {
            for (InstruccionIntermedia inst : codigoIntermedio) {
                pw.println(inst);
            }
        } catch (IOException e) {
            System.err.println("No se pudo escribir el archivo de codigo intermedio.");
        }
    }

    // Contador para generar nombres unicos de etiquetas
    private int contadorEtiquetas = 0;

    /**
     * Genera una nueva etiqueta con un nombre base
     * @param base prefijo de la etiqueta
     * @return etiqueta generada (ej: et_if_0, et_else_1...)
     */
    public String nuevaEtiqueta(String base) {
        return "et_" + base + "_" + (contadorEtiquetas++);
    }
:}

//Lista de terminales 
terminal INT_LITERAL, FLOAT_LITERAL, BOOLEAN_LITERAL, STRING_LITERAL, CHAR_LITERAL;
terminal IF, ELIF, ELSE, WHILE, FOR, DO, BREAK;
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;
terminal INT_MATRIX, FLOAT_MATRIX, STRING_MATRIX, CHAR_MATRIX, BOOLEAN_MATRIX;
terminal ADDITION_ONE, SUBTRACT_ONE, POWERS, ADDITION, SUBTRACT, MULTIPLICATION, DIVISION, MODULE;
terminal CONJUNCTION, DISJUNCTION, DENIAL;
terminal EQ, NEQ, LE, LT, GE, GT;
terminal BRACKET, LBRACKET, RBRACKET, COMMA;
terminal PARENTHESIS_L, PARENTHESIS_R, END_LINE, OPEN_BLOCK, CLOSE_BLOCK;
terminal ASSIGN;
terminal READ_INT, READ_FLOAT, WRITE_INT, WRITE_FLOAT, WRITE_STRING, WRITE_BOOLEAN;
terminal RETURN, COMMENT_BLOCK, COMMENT_LINE, MAIN;
terminal ID, VOID;

// Lista de no terminales
non terminal programa, main_func, func_decl, func_list, param_list, param, block;
non terminal stmt_list, stmt, var_decl, assign_stmt, var_decl_asisgn_stmt;
non terminal expr, arith_expr, rel_expr, logic_expr, literal, control_struct;
non terminal if_elif_else_stmt, if_block, elif_blocks, elif_block, else_block;
non terminal do_while_stmt, for_stmt, return_stmt, break_stmt, type, simple_type, matrix_type, comment;
non terminal func_call, arg_list, write_stmt, read_stmt;
non terminal array_decl, array_int_expr, array_int_expr_list, for_assign;

// Precedencias
precedence left EQ, NEQ, LT, LE, GT, GE;
precedence left ADDITION, SUBTRACT;
precedence left MULTIPLICATION, DIVISION, MODULE;
precedence right POWERS;
precedence left PARENTHESIS_L;
precedence left PARENTHESIS_R;
precedence left CONJUNCTION, DISJUNCTION;

start with programa;
// *******************************************************PROGRAMA***************************************************************************
// Produccion principal que representa un programa completo
// Un programa consiste en una lista de funciones
programa ::= 
    func_list;

// ******************************************************MAIN_FUNC****************************************************************************
// Produccion para declarar la funcion principal 'main'
// Sintaxis: void main() { ... }
main_func ::= VOID MAIN:main PARENTHESIS_L PARENTHESIS_R
{:
    // Se crea la funcion main con tipo de retorno void
    int row = 0;
    int column = 0;
    Function function = createFunction("void", "main", row, column);
    if(function == null){
        semantic_error(null, "La función main está repetida.");
    }
    else{
        parser.codigoIntermedio.add(new InicioFuncionInstr("main"));
    }
    RESULT = null;
:}
    block; // El cuerpo de la funcion main

// ***************************************************DECLARACION*DE*FUNCIONES*******************************************************************************
// Produccion para la declaracion de funciones generales
// Sintaxis: <tipo> <nombre>(<parametros>) { ... }
func_decl ::= type:typeFunction ID:name
{:
    if(typeFunction != null && name != null){
        // Se obtiene el nombre y tipo de la funcion
        String nameFunction = name.toString();
        String typeAux = typeFunction.toString();
        Function function = createFunction(typeAux, nameFunction, 0, 0);
        if(function == null){
            semantic_error(null, "La función " + nameFunction + " está repetida.");
        }
        else{
            parser.codigoIntermedio.add(new InicioFuncionInstr(nameFunction));
        }
        RESULT = null;
    }
:}
    PARENTHESIS_L param_list:params PARENTHESIS_R
{:
    if(params != null){
        // Se registra la lista de parametros en la funcion
        String paramsFunction = params.toString();
        String nameFunction = name.toString();
        Function function = Functions.get(nameFunction);
        function.setArguments(paramsFunction);
    }
:}
    block; // El cuerpo de la funcion

// **************************************************LISTAS*DE*FUNCIONES******************************************************************************
// Listas de funciones
func_list ::=
    func_decl func_list
    | comment func_list
    | main_func
    | error ;

// ***********************************************LISTA*DE*PARAMETROS*********************************************************************************
// Produccion para la lista de parametros de una funcion
// Puede ser una lista separada por comas o un solo parametro
param_list ::=
    param:type COMMA param_list:typeList
{:
    if(type != null && typeList != null){
        String types = typeList.toString();
        String typeVar = type.toString();
        RESULT = typeVar + " " + types;
    }
:}
    | param:type
{:
    if(type != null)
        RESULT = type.toString();
:}
    | {:RESULT = null;:};

// ************************************************PARAMETROS**********************************************************************************
// Produccion que representa un parametro individual de una funcion
// Esta compuesto por un tipo y un identificador (nombre de variable)

param ::= type:typeVar ID:name
{:
    if(ActualTable != null && typeVar != null && name != null){
        String nameVarAux = name.toString();
        String typeAux = typeVar.toString();
        int row = 0;
        int column = 0;
        LineaTabla line = createVar(typeAux, nameVarAux, row, column, true);
        if(line == null){
            semantic_error(null, "El identificador " + nameVarAux + " está repetido.");
        }
        else{
            parser.codigoIntermedio.add(new ParamInstr(typeAux, nameVarAux));
        }
        RESULT = typeAux;
    }
:};


// ***************************************************BLOQUE*DE*CODIGO*****************************************************************************
// Produccion que representa un bloque de codigo delimitado por llaves
// Se crea un nuevo ambito (tabla de simbolos) al entrar al bloque
block ::=
    OPEN_BLOCK
{:
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable, ActualTable.getNombre());
        ActualTable.AgregarHijo(table);
        ActualTable = table;
    }
:}
    stmt_list
    CLOSE_BLOCK
{:
    if(ActualTable != null){
        RESULT = ActualTable;
        ActualTable = ActualTable.getPadre();
    }
:};

// ************************************************LISTA*DE*SENTENCIAS********************************************************************************
// Produccion que representa una lista de instrucciones (sentencias)
// Puede ser una secuencia de sentencias o una sola sentencia
stmt_list ::=
    stmt stmt_list
    | ;

// ***********************************************SENTENCIAS***********************************************************************************
// Produccion que representa una instruccion individual (sentencia)
// Las instrucciones pueden ser declaraciones, asignaciones, llamadas a funciones, etc.
stmt ::= 
    var_decl END_LINE              // Declaracion de variable sin inicializacion
    | assign_stmt END_LINE         // Asignacion de valor a una variable ya declarada
    | var_decl_asisgn_stmt END_LINE // Declaracion de variable con inicializacion
    | control_struct END_LINE      // Estructura de control (ej. if, while, for) seguida por fin de linea
    | control_struct               // Estructura de control sin necesidad de fin de linea
    | read_stmt END_LINE           // Instruccion de lectura
    | write_stmt END_LINE          // Instruccion de escritura
    | return_stmt END_LINE         // Instruccion de retorno
    | break_stmt END_LINE          // Instruccion de ruptura (break)
    | array_decl END_LINE          // Declaracion de arreglo
    | func_call END_LINE           // Llamada a una funcion
    | comment                      // Comentario
    | error END_LINE;              // Captura de errores sintacticos con fin de linea

// ***************************************DECLARACION*DE*VARIABLE*****************************************************************************************
// Produccion que representa la declaracion de una variable sin inicializar.
// Sintaxis esperada: tipo nombre_variable
var_decl ::= 
    type:typeVar ID:name
{:
    // Verifica que exista una tabla de simbolos activa y que los datos no sean nulos
    if(ActualTable != null && typeVar != null && name != null){
        String nameVar = name.toString(); // Se obtiene el tipo de la variable
        String type = typeVar.toString();           // Se obtiene el nombre de la variable
        LineaTabla line = createVar(type, nameVar, 0, 0, false);
        if(line == null){
            semantic_error(null, "El identificador " + nameVar + " está repetido.");
        }
        RESULT = line;
    }
:};

// **************************************Declaracion*DE*ARRAYS******************************************************************************************
// Produccion que representa la declaracion de arreglos unidimensionales o bidimensionales.
// Sintaxis esperada:
//   tipo nombre_arreglo[expresion]
//   tipo nombre_arreglo[expresion][expresion]
// Tambien permite declarar usando el no terminal matrix_type, que encapsula la declaracion completa.

array_decl ::= 
    type:typeArray ID:name LBRACKET expr:typeIndex RBRACKET
{:
    if(ActualTable != null && typeArray != null && name != null && typeIndex != null){
        String typeArrayAux = typeArray.toString() + "Array";
        String nameAux = name.toString();
        String[] typeIndexAux = (String[]) typeIndex;
        if(typeIndexAux[0].equals("int")){
            LineaTabla line = createVar(typeArrayAux, nameAux, 0, 0, false);
            if(line == null){
                semantic_error(null, "El identificador " + nameAux + " está repetido.");
            }
            RESULT = line;
        }
        else{
            semantic_error(null, "El tamaño del arreglo debe " +
                "ser entero. En cambio, se ingresó un tipo " + typeIndexAux[0] +
                " con el identificador en el índice.");
        }
    }
:}
    // Declaracion de arreglo unidimensional con su tamaño definido por una expresion
    | type ID LBRACKET expr RBRACKET LBRACKET expr RBRACKET
    // Declaracion de arreglo bidimensional con ambas dimensiones definidas por expresiones
    | matrix_type;
    // Alternativamente, se permite usar una forma preprocesada a traves de matrix_type

// *******************************************ASIGNACIONES***************************************************************************************
// Produccion que representa las distintas formas de asignacion

assign_stmt ::= 

    // Asignacion de una expresion a una variable
    // Ejemplo: x = 5 + 3
    ID:name ASSIGN expr:type 
    {:
        if (ActualTable != null && name != null && type != null) {
            String id = name.toString();
            String[] tipoValor = (String[]) type; // tipo y valor temporal
            String tipoExpr = tipoValor[0];
            String valorExpr = tipoValor[1];

            LineaTabla line = ActualTable.BuscarDato(id);
            if (line == null || !ActualTable.setInicializacionDato(id, true)) {
                semantic_error(null, "El identificador " + id + " no existe.");
            } else if (!tipoExpr.equals(line.getTipo())) {
                semantic_error(null, "Error semantico: no se puede asignar el tipo " +
                    tipoExpr + " a la variable " + id + " de tipo " + line.getTipo() + ".");
            } else {
                parser.codigoIntermedio.add(new AsignacionInstr(id, valorExpr));
                if (ActualTable != null) {
                    ActualTable.agregarInstruccion(new AsignacionInstr(id, valorExpr));
                }
            }
        }
    :}

    // Asignacion a una posicion especifica en una matriz bidimensional
    // Ejemplo: m[1][2] = 9;
    | ID:name LBRACKET expr:typeIndexOne RBRACKET LBRACKET expr:typeIndexTwo RBRACKET ASSIGN expr:typeExpr
{:
    if (ActualTable != null && name != null && typeIndexOne != null && typeIndexTwo != null && typeExpr != null) {
        String id = name.toString();
        String[] typeIndexOneAux = (String[]) typeIndexOne;
        String[] typeIndexTwoAux = (String[]) typeIndexTwo;
        String[] typeExprAux = (String[]) typeExpr;
        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null) {
            semantic_error(null, "El identificador " + id + " no existe");
        } else if (!line.getEstaInicializado()) {
            semantic_error(null, "No se ha inicializado el identificador " + id);
        } else if (!line.getTipo().contains(typeExprAux[0])) {
            semantic_error(null, "Error semántico en la línea " + currentLine() +
                ": No se puede asignar al identificador " + id + " con tipo " +
                line.getTipo() + " una expresión de tipo " + typeExprAux[0] + ".");
        } else if (!typeIndexOneAux[0].equals("int")) {
            semantic_error(null, "Error semántico en la línea " + currentLine() +
                ": El índice debe ser un entero. En cambio, se ingresó un " +
                "tipo " + typeIndexOneAux[0] + ".");
        } else if (!typeIndexTwoAux[0].equals("int")) {
            semantic_error(null, "Error semántico en la línea " + currentLine() +
                ": El índice debe ser un entero. En cambio, se ingresó un " +
                "tipo " + typeIndexTwoAux[0] + ".");
        } else {
            RESULT = new String[] { line.getTipo(), id };
        }
    }

:}

    // Asignacion a una posicion especifica en un arreglo unidimensional
    // Ejemplo: v[3] = 7;
    | ID:name LBRACKET expr:typeIndex RBRACKET ASSIGN expr:typeExpr
{:
    if (ActualTable != null && name != null && typeIndex != null && typeExpr != null) {
        String id = name.toString();
        String[] typeIndexAux = (String[]) typeIndex;
        String[] typeExprAux = (String[]) typeExpr;
        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null) {
            semantic_error(null, "El identificador " + id + " no existe");
        } else if (!line.getEstaInicializado()) {
            semantic_error(null, "No se ha inicializado el identificador " + id);
        } else if (!line.getTipo().contains(typeExprAux[0])) {
            semantic_error(null, "Error semántico en la línea " + currentLine() +
                ": No se puede asignar al identificador " + id + " con tipo " +
                line.getTipo() + " una expresión de tipo " + typeExprAux[0] + ".");
        } else if (!typeIndexAux[0].equals("int")) {
            semantic_error(null, "Error semántico en la línea " + currentLine() +
                ": El índice debe ser un entero. En cambio, se ingresó un " +
                "tipo " + typeIndexAux[0] + ".");
        } else {
            RESULT = new String[] { line.getTipo(), id };
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new ArrayAsign(id, typeIndexAux[1], typeExprAux[1]));
        }
    }
    RESULT = null; // Asignacion a matrices aun no genera codigo intermedio
:}

    // Operador de incremento (preincremento)
    // Ejemplo: ++x;
    | ADDITION_ONE ID:name 
    {:
        if (ActualTable != null && name != null) {
            String id = name.toString();
            LineaTabla line = ActualTable.BuscarDato(id);
            if (line == null) {
                semantic_error(null, "El identificador " + id + " no existe.");
            } else if (!line.getTipo().equals("int")) {
                semantic_error(null, "El operador ++ solo se permite sobre enteros.");
            } else {
                String temp = parser.nuevoTemporal();
                parser.codigoIntermedio.add(new OperacionInstr(temp, id, "+", "1"));
                parser.codigoIntermedio.add(new AsignacionInstr(id, temp));
            }
        }
    :}

    // Operador de decremento (predecremento)
    // Ejemplo: --x;
    | SUBTRACT_ONE ID:name 
    {:
        if (ActualTable != null && name != null) {
            String id = name.toString();
            LineaTabla line = ActualTable.BuscarDato(id);
            if (line == null) {
                semantic_error(null, "El identificador " + id + " no existe.");
            } else if (!line.getTipo().equals("int")) {
                semantic_error(null, "El operador -- solo se permite sobre enteros.");
            } else if (!line.getEstaInicializado()) {
                semantic_error(null, "No se ha inicializado el identificador " + id);
            } else {
                String temp = parser.nuevoTemporal();
                parser.codigoIntermedio.add(new OperacionInstr(temp, id, "-", "1"));
                parser.codigoIntermedio.add(new AsignacionInstr(id, temp));
            }
        }
    :};


// ******************************DECLARACION*CON*ASIGNACION**************************************************************************************************
// Produccion que representa una declaracion de variable seguida de una asignacion
// Ejemplos: 
//    int x = 5;
//    int z = x + 2;

// Caso 1: Declaracion de variable simple con asignacion
var_decl_asisgn_stmt ::= var_decl:var ASSIGN expr:type
{:
    if (ActualTable != null && var != null && type != null) {
        String[] tipoValor = (String[]) type; // tipo y valor temporal
        String tipoExpr = tipoValor[0];       // tipo de la expresion
        String valorExpr = tipoValor[1];      // resultado o temporal de la expresion

        LineaTabla line = (LineaTabla) var;   // linea correspondiente a la variable declarada
        if (line == null || !ActualTable.setInicializacionDato(line.getNombre(), true)) {
            semantic_error(null, "El identificador " + line.getNombre() + " no existe");
        } 
        else if (!tipoExpr.equals(line.getTipo())) {
            semantic_error(null, "Error semantico: no se puede asignar el tipo " +
                tipoExpr + " a la variable " + line.getNombre() + " con tipo " +
                line.getTipo() + ".");
        } 
        else {
            // Codigo intermedio para declaracion con asignacion
            parser.codigoIntermedio.add(new DeclAsigInstr(line.getTipo(), line.getNombre(), valorExpr));
        }
    }
:}

// Caso 2: Declaracion de arreglo (1D o 2D) con asignacion (no implementado aun)
// Ejemplo: int matriz[2][2] = expr;
| array_decl:array ASSIGN expr:typeExpr
{:
    if (ActualTable != null && array != null && typeExpr != null) {
        LineaTabla varLine = (LineaTabla) array;
        String[] typeExprAux = (String[]) typeExpr;
        if (varLine == null || !ActualTable.setInicializacionDato(varLine.getNombre(), true)) {
            semantic_error(null, varLine.getNombre() + " no existe.");
        }
        else if(!varLine.getTipo().equals(typeExprAux[0])){
            semantic_error(null, "No se le puede asignar el tipo " + typeExprAux[0] + " al " +
            " idenficador " + varLine.getNombre() + " con tipo " +
            varLine.getTipo() + ".");
        }
        else{
            parser.codigoIntermedio.add(new DeclAsigInstr(varLine.getTipo(), varLine.getNombre(), typeExprAux[1]));
        }
    }
    RESULT = null; // Asignacion a matrices aun no genera codigo intermedio
:};


// **********************************************************************************************************************************
expr ::=
    func_call:type
{:
    if(type != null)
        RESULT = type;
:}
    | PARENTHESIS_L expr:type PARENTHESIS_R
{:
    if(type != null)
        RESULT = type;
:}
    | arith_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | rel_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | logic_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | array_int_expr:type
{:
    if(type != null)
        RESULT = type;
:}
    | literal:type
{:
    if(type != null)
        RESULT = type;
:}
    | ID:idDeclarated
{:
    if (ActualTable != null && idDeclarated != null) {
        String id = idDeclarated.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if (line == null) {
            semantic_error(null, "El identificador " + id + " no existe.");
        } else if (!line.getEstaInicializado()) {
            semantic_error(null, "No se ha inicializado el identificador " + id);
        } else {
            RESULT = new String[] { line.getTipo(), id };
        }
    }
:}

    | ADDITION_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "El identificador " + id + " no existe.");
        }
        else{
            if(!line.getTipo().equals("int")){
                semantic_error(null, "No se permite el uso del ++ con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
            }
            else if(!line.getEstaInicializado()){
                semantic_error(null, "No se ha inicializado el identificador " +
                    line.getNombre());
            }
            else{
                RESULT = new String[] {line.getTipo(), id};
            }
        }
    }
:}
    | SUBTRACT_ONE ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "El identificador " + id + " no existe");
        }
        else{
            if(!line.getTipo().equals("int")){
                semantic_error(null, "No se permite el uso del -- con el tipo " +
                    line.getTipo() + " en el identificador " + line.getNombre());
            }
            else if(!line.getEstaInicializado()){
                semantic_error(null, "No se ha inicializado el identificador " +
                    line.getNombre());
            }
            else{
                RESULT = new String[] {line.getTipo(), id};
            }
        }
    }
:};

// **********************************************************************************************************************************
array_int_expr ::=
    BRACKET array_int_expr_list:numArray BRACKET
{:
    String numArrayAux = numArray.toString();
    String temp = parser.nuevoTemporal();
    parser.codigoIntermedio.add(new AsignacionInstr(temp, "|" + numArrayAux + "|"));
    RESULT = new String[] {"intArray", temp};
:}
    | BRACKET BRACKET;

// **********************************************************************************************************************************
array_int_expr_list ::=
    INT_LITERAL:num COMMA array_int_expr_list:numArray
{:
    String numAux = num.toString();
    String numArrayAux = numArray.toString();
    RESULT = numAux + "," + numArrayAux;
:}
    | INT_LITERAL:num
{:
    RESULT = num.toString();
:};

// ******************************EXPRESIONES*ARITMETICAS***************************************************************************************************
// Produccion para operaciones aritmeticas: suma, resta, multiplicacion, division, modulo y negacion unaria

arith_expr ::=

    // Suma: expr + expr
    expr:e1 ADDITION expr:e2
{:
    // Se extraen tipos y valores de ambas expresiones
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "+", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede sumar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}

    // Resta: expr - expr
| expr:e1 SUBTRACT expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "-", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede restar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}

    // Multiplicacion: expr * expr
| expr:e1 MULTIPLICATION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "*", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede multiplicar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 POWERS expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "*", val2));

            RESULT = new String[] {
                (tipo1.equals("float") || tipo2.equals("float")) ? "float" : "int",
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede multiplicar " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}

    // Division: expr / expr
| expr:e1 DIVISION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "/", val2));

            RESULT = new String[] {
                "float", // La division siempre se interpreta como flotante
                temp
            };
        } else {
            Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
            parser.semantic_error(operador, "no se puede dividir " + tipo1 + " con " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}

    // Modulo: expr % expr (solo para enteros)
| expr:e1 MODULE expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            tipo1.equals("int") && tipo2.equals("int")) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "%", val2));

            RESULT = new String[] { "int", temp };
        }
    } else {
        Symbol operador = (Symbol) CUP$parser$stack.elementAt(CUP$parser$top - 1);
        parser.semantic_error(operador, "el operador modulo solo se permite entre enteros");
        RESULT = new String[] { "error", "" };
    }
:}

    // Negacion unaria: -expr
| SUBTRACT expr:e
{:
    String[] v = (String[]) e;
    if(ActualTable != null && e != null){
        String tipo = v[0];
        String val = v[1];

        if (ActualTable != null && e != null &&
            (tipo.equals("int") || tipo.equals("float"))) {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, "-", val, ""));
            RESULT = new String[] { tipo, temp };
        } else {
            parser.semantic_error(null, "el operador unario '-' solo se permite para enteros o flotantes");
            RESULT = new String[] { "error", "" };
        }
    }
:};

// **********************************************************************************************************************************
rel_expr ::= expr:e1 LT expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "<", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'<' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 LE expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "<=", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'<=' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 GT expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, ">", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'>' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 GE expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (ActualTable != null && e1 != null && e2 != null &&
            (tipo1.equals("int") || tipo1.equals("float")) &&
            (tipo2.equals("int") || tipo2.equals("float"))) {

            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, ">=", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "'>=' no válido entre " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 EQ expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];
        if (tipo1.equals(tipo2)) {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "==", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "comparación '==' entre tipos diferentes: " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:}
| expr:e1 NEQ expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;
    if(ActualTable != null && e1 != null && e2 != null){
        String tipo1 = v1[0], val1 = v1[1];
        String tipo2 = v2[0], val2 = v2[1];

        if (tipo1.equals(tipo2)) {
            String temp = parser.nuevoTemporal();
            parser.codigoIntermedio.add(new OperacionInstr(temp, val1, "!=", val2));
            RESULT = new String[] { "boolean", temp };
        } else {
            parser.semantic_error(null, "comparación '!=' entre tipos diferentes: " + tipo1 + " y " + tipo2);
            RESULT = new String[] { "error", "" };
        }
    }
:};


// **********************************************************************************************************************************
logic_expr ::= expr:e1 CONJUNCTION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;

    if (ActualTable != null && e1 != null && e2 != null &&
        v1[0].equals("boolean") && v2[0].equals("boolean")) {
        String temp = parser.nuevoTemporal();
        parser.codigoIntermedio.add(new OperacionInstr(temp, v1[1], "&&", v2[1]));
        RESULT = new String[] { "boolean", temp };
    } else {
        parser.semantic_error(null, "'&&' solo aplica a booleanos, recibió " + v1[0] + " y " + v2[0]);
        RESULT = new String[] { "error", "" };
    }
:}
| expr:e1 DISJUNCTION expr:e2
{:
    String[] v1 = (String[]) e1;
    String[] v2 = (String[]) e2;

    if (ActualTable != null && e1 != null && e2 != null &&
        v1[0].equals("boolean") && v2[0].equals("boolean")) {
        String temp = parser.nuevoTemporal();
        parser.codigoIntermedio.add(new OperacionInstr(temp, v1[1], "||", v2[1]));
        RESULT = new String[] { "boolean", temp };
    } else {
        parser.semantic_error(null, "'||' solo aplica a booleanos, recibió " + v1[0] + " y " + v2[0]);
        RESULT = new String[] { "error", "" };
    }
:}
| DENIAL expr:e
{:
    String[] v = (String[]) e;

    if (ActualTable != null && e != null && v[0].equals("boolean")) {
        String temp = parser.nuevoTemporal();
        parser.codigoIntermedio.add(new OperacionUnariaInstr(temp, "!", v[1]));
        RESULT = new String[] { "boolean", temp };
    } else {
        parser.semantic_error(null, "negación (!) solo aplica a booleanos, recibió " + v[0]);
        RESULT = new String[] { "error", "" };
    }
:};


// **********************************************************************************************************************************
for_assign ::=
    assign_stmt
    | var_decl_asisgn_stmt;

literal ::= INT_LITERAL:n
{:
    RESULT = new String[] { "int", n.toString() };
:}
| FLOAT_LITERAL:n
{:
    RESULT = new String[] { "float", n.toString() };
:}
| BOOLEAN_LITERAL:n
{:
    RESULT = new String[] { "boolean", n.toString() };
:}
| STRING_LITERAL:n
{:
    RESULT = new String[] { "string", n.toString() };
:}
| CHAR_LITERAL:n
{:
    RESULT = new String[] { "char", n.toString() };
:};

// **********************************************************************************************************************************
control_struct ::=
    if_elif_else_stmt {::}
    | do_while_stmt
    | for_stmt;

// **********************************************************************************************************************************
if_elif_else_stmt ::=
{:
    if(ActualTable != null){
        String etiquedaInicio = nuevaEtiqueta("if_elif_else_inicio");
        String etiquedaIntermedia = nuevaEtiqueta("if_elif_else_intermedio");
        String etiquetaFin = nuevaEtiqueta("if_elif_else_final");
        PilaControl.add(new EtiquetaEstructura(etiquedaInicio,
            etiquedaIntermedia, etiquetaFin));
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaInicio));
    }
:}
    if_block elif_blocks else_block
{:
    if(ActualTable != null){
        EtiquetaEstructura iterador = PilaControl.get(PilaControl.size()-1);
        parser.codigoIntermedio.add(new EtiquetaInstr(iterador.getEtiquetaFinal()));
        PilaControl.removeLast();
    }
:};

if_block ::=
    IF PARENTHESIS_L expr:cond PARENTHESIS_R
{:
    if(ActualTable != null && cond != null){
        String[] condicion = (String[]) cond;
        if(condicion[0].equals("boolean")){
            String etiquedaInicio = nuevaEtiqueta("if_inicio");
            String etiquedaIntermedia = nuevaEtiqueta("if_intermedio");
            String etiquetaFin = nuevaEtiqueta("if_final");
            PilaControl.add(new EtiquetaEstructura(etiquedaInicio,
                etiquedaIntermedia, etiquetaFin));
            parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaInicio));
            parser.codigoIntermedio.add(new IfGotoInstr(condicion[1], etiquedaIntermedia));
            parser.codigoIntermedio.add(new GotoInstr(etiquetaFin));
            parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaIntermedia));
        }
        else{
            semantic_error(null, "La estructura de control if " +
                "espera un tipo booleano en su argumento, en cambio se envió " +
                "un tipo " + condicion[0] + ".");
        }
    }
:}
    block:blockData
{:
    if(ActualTable != null && cond != null && blockData != null){
        TablaDeSimbolos table = (TablaDeSimbolos) blockData;
        table.setNombre("if");
        EtiquetaEstructura estructura = PilaControl.removeLast();
        EtiquetaEstructura estructuraPadre = PilaControl.get(PilaControl.size()-1);
        parser.codigoIntermedio.add(new GotoInstr(estructuraPadre.getEtiquetaFinal()));
        parser.codigoIntermedio.add(new EtiquetaInstr(estructura.getEtiquetaFinal()));
    }
:};

// ***********************************BLOQUES*ELIF**********************************************************************************************
elif_blocks ::= 
    elif_block elif_blocks
    | ;

// **********************************************************************************************************************************
elif_block ::= 
    ELIF PARENTHESIS_L expr:cond PARENTHESIS_R
{:
    if(ActualTable != null && cond != null){
        String[] condicion = (String[]) cond;
        if(condicion[0].equals("boolean")){
            String etiquedaInicio = nuevaEtiqueta("elif_inicio");
            String etiquedaIntermedia = nuevaEtiqueta("elif_intermedio");
            String etiquetaFin = nuevaEtiqueta("elif_final");
            PilaControl.add(new EtiquetaEstructura(etiquedaInicio,
                etiquedaIntermedia, etiquetaFin));
            parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaInicio));
            parser.codigoIntermedio.add(new IfGotoInstr(condicion[1], etiquedaIntermedia));
            parser.codigoIntermedio.add(new GotoInstr(etiquetaFin));
            parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaIntermedia));
        }
        else{
            semantic_error(null, "La estructura de control if " +
                "espera un tipo booleano en su argumento, en cambio se envió " +
                "un tipo " + condicion[0] + ".");
        }
    }
:}
    block:blockData
{:
    if(ActualTable != null && cond != null && blockData != null){
        TablaDeSimbolos table = (TablaDeSimbolos) blockData;
        table.setNombre("elif");
        EtiquetaEstructura estructura = PilaControl.removeLast();
        EtiquetaEstructura estructuraPadre = PilaControl.get(PilaControl.size()-1);
        parser.codigoIntermedio.add(new GotoInstr(estructuraPadre.getEtiquetaFinal()));
        parser.codigoIntermedio.add(new EtiquetaInstr(estructura.getEtiquetaFinal()));
    }
:};

else_block ::=
    ELSE block:blockData
{:
    if(ActualTable != null && blockData != null){
        TablaDeSimbolos table = (TablaDeSimbolos) blockData;
        table.setNombre("else");
        EtiquetaEstructura estructuraPadre = PilaControl.get(PilaControl.size()-1);
        parser.codigoIntermedio.add(new GotoInstr(estructuraPadre.getEtiquetaFinal()));
    }
:}
    | ;

// **********************************************************************************************************************************
do_while_stmt ::=
    DO
{:
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable, "do_while");
        ActualTable.AgregarHijo(table);
        ActualTable = table;
        String etiquedaInicio = nuevaEtiqueta("do-while_inicio");
        String etiquedaIntermedia = nuevaEtiqueta("do-while_intermedio");
        String etiquetaFin = nuevaEtiqueta("do-while_final");
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaInicio));
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaIntermedia));
        PilaIteradores.add(new EtiquetaEstructura(etiquedaInicio, etiquedaIntermedia, etiquetaFin));
    }
:}
    block WHILE PARENTHESIS_L expr:type PARENTHESIS_R
{:
    if(ActualTable != null && type != null){
        ActualTable = ActualTable.getPadre();
        String[] typeExpr = (String[]) type;
        if(!typeExpr[0].equals("boolean")){
            semantic_error(null, "do-while necesita una " +
                "expresion de tipo booleano para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr[0] + ".");
        }
        else{
            EtiquetaEstructura iterador = PilaIteradores.get(PilaIteradores.size()-1);
            parser.codigoIntermedio.add(new IfFalseInstr(typeExpr[1], iterador.getEtiquetaFinal()));
            parser.codigoIntermedio.add(new GotoInstr(iterador.getEtiquetaIntermedio()));
            parser.codigoIntermedio.add(new EtiquetaInstr(iterador.getEtiquetaFinal()));
            PilaIteradores.removeLast();
        }
    }
:};

// **********************************************************************************************************************************
for_stmt ::=
    FOR
{:
    if(ActualTable != null){
        TablaDeSimbolos table = new TablaDeSimbolos(ActualTable, "for");
        ActualTable.AgregarHijo(table);
        ActualTable = table;
        String etiquedaInicio = nuevaEtiqueta("for_inicio");
        String etiquedaIntermedia = nuevaEtiqueta("for_intermedio");
        String etiquetaFin = nuevaEtiqueta("for_final");
        parser.codigoIntermedio.add(new EtiquetaInstr(etiquedaInicio));
        PilaIteradores.add(new EtiquetaEstructura(etiquedaInicio, etiquedaIntermedia, etiquetaFin));
    }
:}
    PARENTHESIS_L for_assign END_LINE
{:
    if(ActualTable != null){
        EtiquetaEstructura iterador = PilaIteradores.get(PilaIteradores.size()-1);
        parser.codigoIntermedio.add(new EtiquetaInstr(iterador.getEtiquetaIntermedio()));
    }
:}
    expr:type END_LINE
{:
    if(ActualTable != null && type != null){
        String[] typeAux = (String[]) type;
        EtiquetaEstructura iterador = PilaIteradores.get(PilaIteradores.size()-1);
        parser.codigoIntermedio.add(new IfFalseInstr(typeAux[1], iterador.getEtiquetaFinal()));
    }
:}
    assign_stmt PARENTHESIS_R block
{:
    if(ActualTable != null && type != null){
        ActualTable = ActualTable.getPadre();
        String[] typeExpr = (String[]) type;
        if(!typeExpr[0].equals("boolean")){
            semantic_error(null, "for necesita una " +
                "expresion de tipo booleano para en su segundo parámetro para funcionar. En cambio, se " +
                "una expresion de tipo " + typeExpr[0] + ".");
        }
        else{
            EtiquetaEstructura iterador = PilaIteradores.get(PilaIteradores.size()-1);
            parser.codigoIntermedio.add(new GotoInstr(iterador.getEtiquetaIntermedio()));
            parser.codigoIntermedio.add(new EtiquetaInstr(iterador.getEtiquetaFinal()));
            PilaIteradores.removeLast();
        }
    }
:};

// **********************************************************************************************************************************
/**
 * Produccion para la sentencia de retorno.
 * Valida que el tipo de retorno coincida con el tipo declarado de la funcion
 * y genera la instruccion intermedia correspondiente.
 */
return_stmt ::= RETURN expr:type
{:
    if(ActualTable != null && type != null){
        String[] typeReturn = (String[]) type;
        String valorReturn = typeReturn[1];
        if(!typeReturn[0].equals(ActualFunction.getTipo())){
            semantic_error(null, "El valor retornado " +
                typeReturn[0] + " no corresponde con el tipo de retorno " +
                ActualFunction.getTipo() + " de la funcion " +
                ActualFunction.getNombre() + ".");
        }

        // Agregar instruccion intermedia para return
        parser.codigoIntermedio.add(new ReturnInstr(valorReturn));
        ActualTable.agregarInstruccion(new ReturnInstr(valorReturn));
    }
:};


// **********************************************************************************************************************************
break_stmt ::= BREAK:name
{:
    if(ActualTable != null){
        TablaDeSimbolos actualTable = ActualTable;
        while (actualTable != null){
            if(ActualTable.getNombre().equals("for")
                || ActualTable.getNombre().equals("do_while"))
                break;
            actualTable = actualTable.getPadre();
        }
        if(actualTable == null){
            semantic_error(null, "El BREAK solo puede utilizarse"
                + " dentro de iteradores for o do-while");
        }
        else{
            EtiquetaEstructura iterador = PilaIteradores.get(PilaIteradores.size()-1);
            parser.codigoIntermedio.add(new GotoInstr(iterador.getEtiquetaFinal()));
        }
    }
:};

// **********************************************************************************************************************************
type ::= 
    simple_type:typeString {: RESULT = typeString.toString(); :}
    | matrix_type:typeString {: RESULT = typeString.toString(); :};

// **********************************************************************************************************************************
simple_type ::=
    INT {:RESULT = "int";:}
    | FLOAT {:RESULT = "float";:}
    | BOOLEAN {:RESULT = "boolean";:}
    | CHAR {:RESULT = "char";:}
    | STRING {:RESULT = "string";:};

// **********************************************************************************************************************************
matrix_type ::=
    INT_MATRIX {:RESULT = "intMatrix";:}
    | FLOAT_MATRIX {:RESULT = "floatMatrix";:}
    | STRING_MATRIX {:RESULT = "stringMatrix";:}
    | CHAR_MATRIX {:RESULT = "charMatrix";:}
    | BOOLEAN_MATRIX {:RESULT = "booleanMatrix";:};

// **********************************************************************************************************************************
comment ::= 
    COMMENT_BLOCK
    | COMMENT_LINE;

// **********************************************************************************************************************************
/**
 * Produccion para la llamada a una funcion con argumentos.
 * Se valida si la funcion existe, si los tipos de argumentos coinciden
 * y se devuelve su tipo de retorno si es correcta.
 */
func_call ::=
    ID:name PARENTHESIS_L arg_list:args PARENTHESIS_R
{:
    if (ActualTable != null && args != null && name != null) {
        String nameCall = name.toString();
        String argsCall = args.toString();
        if (Functions.containsKey(nameCall)) {
            Function function = Functions.get(nameCall);
            String argsFunction = function.getArguments();
            if (argsFunction.equals(argsCall)) {
                RESULT = new String[]{ function.getTipo(), nameCall + "()" };

                // Generar codigo intermedio para la llamada a funcion
                parser.codigoIntermedio.add(new OperacionInstr("call", nameCall, "", ""));
                ActualTable.agregarInstruccion(new OperacionInstr("call", nameCall, "", ""));
            } else {
                semantic_error(null, "La funcion " + nameCall +
                    " tiene argumentos de tipo |" + function.getArguments() + "|, pero se enviaron |" +
                    argsCall + "|.");
                RESULT = new String[]{ "error", "" };
            }
        } else {
            semantic_error(null, "La funcion " + nameCall +
                    " no existe");
            RESULT = new String[]{ "error", "" };
        }
    }
:}

/**
 * Produccion para la llamada a una funcion sin argumentos.
 * Se valida la existencia de la funcion y que no espere argumentos.
 */
| ID:name PARENTHESIS_L PARENTHESIS_R
{:
    if (ActualTable != null && name != null) {
        String nameCall = name.toString();
        String argsCall = "";
        if (Functions.containsKey(nameCall)) {
            Function function = Functions.get(nameCall);
            String argsFunction = function.getArguments();
            if (argsFunction.equals(argsCall)) {
                RESULT = new String[]{ function.getTipo(), nameCall + "()" };

                // Generar codigo intermedio para la llamada a funcion
                parser.codigoIntermedio.add(new OperacionInstr("call", nameCall, "", ""));
                ActualTable.agregarInstruccion(new OperacionInstr("call", nameCall, "", ""));
            } else {
                semantic_error(null, "La funcion " + nameCall +
                    " tiene argumentos de tipo |" + argsFunction + "|, pero se enviaron |" +
                    argsCall + "|.");
                RESULT = new String[]{ "error", "" };
            }
        } else {
            semantic_error(null, "No existe la funcion " + nameCall + ".");
            RESULT = new String[]{ "error", "" };
        }
    }
:};


// **********************************************************************************************************************************
arg_list ::= expr:type COMMA arg_list:types
{:
    if(ActualTable != null && type != null && types != null){
        String typesAux = types.toString();
        String[] typeAux = (String[]) type;
        RESULT = typeAux[0] + " " + typesAux;
    }
:}
    | expr:type
{:
    if(ActualTable != null && type != null){
        String[] typeAux = (String[]) type;
        RESULT = typeAux[0];

    }
:};

// **********************************************************************************************************************************
write_stmt ::= 
    WRITE_INT INT_LITERAL:data
{:
    if(ActualTable != null && data != null){
        String dataAux = data.toString();
        parser.codigoIntermedio.add(new OutputInstr("WRITE_INT", nuevoTemporal(), dataAux));
    }
:}
    | WRITE_INT ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "Error semántico: El identificador " +
                id + " no existe");
        }
        else if(!line.getEstaInicializado()){
            semantic_error(null, "No se ha inicializado el identificador " +
                line.getNombre());
        }
        else if(!line.getTipo().equals("int")){
            semantic_error(null, "El identificador debe ser"
                + " de tipo entero");
        }   
        else{
            parser.codigoIntermedio.add(new OutputInstr("WRITE_INT", nuevoTemporal(), id));
        }
    }
:}
    | WRITE_FLOAT FLOAT_LITERAL:data
{:
    if(ActualTable != null && data != null){
        String dataAux = data.toString();
        parser.codigoIntermedio.add(new OutputInstr("WRITE_FLOAT", nuevoTemporal(), dataAux));
    }
:}
    | WRITE_FLOAT ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "Error semántico: El identificador " +
                id + " no existe");
        }
        else if(!line.getEstaInicializado()){
            semantic_error(null, "No se ha inicializado el identificador " +
                line.getNombre());
        }
        else if(!line.getTipo().equals("float")){
            semantic_error(null, "El identificador debe ser"
                + " de tipo flotante.");
        }
        else {
            parser.codigoIntermedio.add(new OutputInstr("WRITE_FLOAT", nuevoTemporal(), id));
        }
    }
:}
    | WRITE_STRING STRING_LITERAL:data
{:
    if(ActualTable != null && data != null){
        String dataAux = data.toString();
        parser.codigoIntermedio.add(new OutputInstr("WRITE_STRING", nuevoTemporal(), dataAux));
    }
:}
    | WRITE_STRING ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "Error semántico: El identificador " +
                id + " no existe");
        }
        else if(!line.getEstaInicializado()){
            semantic_error(null, "No se ha inicializado el identificador " +
                line.getNombre());
        }
        else if(!line.getTipo().equals("string")){
            semantic_error(null, "Error semántico: El identificador debe ser"
                + " de tipo string");
        }
        else {
            parser.codigoIntermedio.add(new OutputInstr("WRITE_STRING", nuevoTemporal(), id));
        }
    }
:}
    | WRITE_BOOLEAN BOOLEAN_LITERAL:data
{:
    if(ActualTable != null && data != null){
        String dataAux = data.toString();
        parser.codigoIntermedio.add(new OutputInstr("WRITE_BOOLEAN", nuevoTemporal(), dataAux));
    }
:}
    | WRITE_BOOLEAN ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "Error semántico: El identificador " +
                id + " no existe");
        }
        else if(!line.getEstaInicializado()){
            semantic_error(null, "No se ha inicializado el identificador " +
                line.getNombre());
        }
        else if(!line.getTipo().equals("boolean")){
            semantic_error(null, "El identificador debe ser"
                + " de tipo booleano");
        }
        else{
            parser.codigoIntermedio.add(new OutputInstr("WRITE_BOOLEAN", nuevoTemporal(), id));
        }
    }
:};

// **********************************************************************************************************************************
read_stmt ::= 
    READ_INT ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "Error semántico: El identificador " +
                id + " no existe");
        }
        else if(!line.getEstaInicializado()){
            semantic_error(null, "No se ha inicializado el identificador " +
                line.getNombre() + ".");
        }
        else if(!line.getTipo().equals("int")){
            semantic_error(null, "Error semántico: El identificador debe ser"
                + " de tipo entero.");
        }
        else{
            parser.codigoIntermedio.add(new InputInstr("READ_INT", nuevoTemporal(), id));
        }
    }
:}
    | READ_FLOAT ID:name
{:
    if(ActualTable != null && name != null){
        String id = name.toString();
        LineaTabla line = ActualTable.BuscarDato(id);
        if(line == null){
            semantic_error(null, "Error semántico: El identificador " +
                id + " no existe");
        }
        else if(!line.getEstaInicializado()){
            semantic_error(null, "No se ha inicializado el identificador " +
                line.getNombre());
        }
        else if(!line.getTipo().equals("float")){
            semantic_error(null, "El identificador debe ser"
                + " de tipo flotante");
        }
        else{
            parser.codigoIntermedio.add(new InputInstr("READ_FLOAT", nuevoTemporal(), id));
        }
    }
:};